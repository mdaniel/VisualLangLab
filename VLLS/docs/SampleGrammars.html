<html>
  <head>
    <title>Sample Grammars</title>
  </head>

  <body>
    <h1>VisualLangLab - Sample Grammars</h1>

    <p>
      So that users may quickly become familiar with grammar-trees, 
      <a href="">VisualLangLab</a> includes two built-in sample grammars that can 
      be inspected and edited. These grammars, one for arithmetic-expressions and 
      another for JSON, can be opened by invoking <i>Help -> Samples -> ArithExpr</i> 
      or <i>Help -> Samples -> SampleJSON</i> from the main menu as shown in Figure-1 
      below.
    </p>

    <img src="images/SampleGrammar1.png"/><br/>
    <i>Figure-1. Opening sample grammars</i>

    <p>
      The grammar-trees of these two parsers are shown in the sub-sections below. 
      However, for best results readers should start 
      <a href="http://vll.java.net">VisualLangLab</a> and use its menus to 
      review the grammar-trees and understand the operations that can be performed on them.
    </p>

    <h2>Reviewing a Parser</h2>

    <p>
      <a href="http://vll.java.net">VisualLangLab</a> provides numerous tools for 
      editing grammar-trees in parsers. Those same tools can also be used to review 
      the structure and properties grammar-trees. The first step in a review 
      is to load (or <i>open</i>) a grammar. Once opened, the tool-bar's ComboBox 
      (deployed in Figure-2 below) can be used to list the constituent grammar-trees, 
      and to select one of them for review (or editing).
    </p>

    <img src="images/GuiComboBox1.png"/><br/>
    <i>Figure-2. Listing and selecting a grammar-tree</i>

    <p>
      Once a grammar-tree is selected and displayed, the arrangement, type, and 
      annotations of the nodes should be examined carefully. The grammar-tree with 
      its icons and annotations reveals most of the information about the corresponding 
      parser clause. However, certain other information (action-code for instance) 
      is not displayed unless the specific grammar-node tree is selected.
    </p>

    <h3>Grammar-Tree Icons & Annotations</h3>

    <p>
      The icons used in the grammar-tree are designed to be intuitive and meaningful 
      to anyone familiar with parsers, and are explained in 
      <a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>.
    </p>

    <h3>Parse-Tree (or AST)</h3>

    <p>
      The structure of the parse-tree (or <i>AST</i>) of the selected grammar-tree node 
      is displayed in the TextArea on the right of the grammar-tree. Observe that the 
      displayed information changes as different grammar-tree nodes are selected. 
      The format of the information displayed is described in 
      <a href="ASTAndActionCode.html">AST and Action Code</a>.
    </p>

    <h3>Action-Code</h3>

    <p>
      Action-code (a Javascript or Scala function assigned to a node to process its AST) 
      can be optionally associated with any grammar-tree node. 
      Action-code associated with any grammar-tree node is displayed (and edited) 
      in the TextArea on the right of the parse-tree.
      The <i>ArithExpr</i> 
      parser described below illustrates action-code functions in both languages. 
      The design of action-code functions is described in 
      <a href="ASTAndActionCode.html">AST and Action Code</a>.
    </p>

    <h3>Test-Running a Parser</h3>

    <p>
      To <i>test-run</i> the displayed grammar-tree just enter the test input 
      (text for the parser's consumption) into the TextArea under 
      <i>Parser Test Input</i> ("A" in Figure-2 below), and click the <i>Parse input</i> 
      toolbar button ("B" in the figure). The results of the run (or any error messages) 
      appear in the <i>Parser Log</i> area ("C" in the figure).
    </p>

    <img src="images/TestingArithExpr1.png"/><br/>
    <i>Figure-3. Testing the ArithExpr parser</i>

    <p>
      Figure-2 above shows the grammar-tree <i>expr</i> of the <i>ArithExpr</i> parser 
      (see below) being tested with the 
      input "2 * (3 + 7)", and producing the output "20".
      The result of parsing ("20") is a number (not a full-fledged AST) 
      because the action-code actually evaluates the AST. Removing the action-code 
      from all three grammar-trees (left as an exercise for the reader), 
      will result in the same input being parsed to the following AST
    </p>

    <code>Array(Array(Pair(0, 2), List(Pair(0, Pair(1, Array(Array(Pair(0, 3), List()), List(Pair(0, Array(Pair(0, 7), List())))))))), List())</code>

    <p>
      If you happen to have <a href="http://lamp.epfl.ch/teaching/foundations_of_software/docs/combinator_parsing.pdf">section 31.1</a> 
      of <a href="http://www.artima.com/shop/programming_in_scala">Programming in Scala (first edition)</a> 
      open in front of you, you'll notice that this result is different from the one in the book. 
      A careful reading of <a href="ASTAndActionCode.html">AST and Action Code</a> should explain everything.
    </p>

    <h2>The ArithExpr Parser</h2>

    <p>
      As mentioned elsewhere, the grammar trees in Figure-2 implement the following 
      grammar clauses:
    </p>

<code>
<pre>    expr ::= term {"*" term | "-" term}
    factor ::= floatingPointNumber | "(" expr ")"
    term ::= factor {"*" factor | "/" factor}</pre>
</code>

    <p>
      However, the process and knowledge used to transcribe a textual grammar 
      (as in the lines above) into a <i>grammar-tree</i> in 
      <a href="http://vll.java.net">VisualLangLab</a> is not described here. 
      That information can be found in 
      <a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>. 
      The purpose of this section is merely to provide a starting point that 
      new users can use to learn the tool's menus and options. 
      The grammar-trees of this parser have some optional but interesting features 
      that should be reviewed carefully. 
    </p>

    <table border="1">
      <tr><td>expr</td><td>factor</td><td>term</td></tr>
      <tr><td><img src="images/GrammarTreeExpr1.png"/></td><td><img src="images/GrammarTreeFactor1.png"/></td><td><img src="images/GrammarTreeTerm1.png"/></td></tr>
    </table>
    <i>Figure-4. Grammar-trees of the ArithExpr parser</i>

    <p>
      All three grammar-trees use an action-code function at the top-level 
      (the node just below the root-node). The action-code of each grammar-tree can be displayed 
      by clicking the top-level node. Note that grammar-tree nodes with associated action-code 
      can be spotted by the presence of the <i>action</i> annotation (within square brackets 
      that group optional annotations).
    </p>

    <p>
      Also note the <i>drop</i> annotation (and the corresponding icon overlay) on several 
      literal tokens in all three grammar-trees. A <i>drop</i>ped part of a grammar-tree 
      contributes nothing to the AST -- though it is expected to be seen in the input. 
      The use of <i>drop</i> is explained fully in 
      <a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>.
    </p>

    <h2>The SimpleJSON Parser</h2>

    <p>
      The grammar-trees of the SimpleJSON parser are shown in Figure-3 below for 
      easy reference.
    </p>

    <table border="1">
      <tr><td>value</td><td>arr</td><td>member</td><td>obj</td></tr>
      <tr><td><img src="images/SampleGrammarJsonValue.png"/></td><td><img src="images/SampleGrammarJsonArr.png"/></td><td><img src="images/SampleGrammarJsonMember.png"/></td><td><img src="images/SampleGrammarJsonObj.png"/></td></tr>
    </table>
    <i>Figure-5. Grammar-trees of the SimpleJSON parser</i>

    <p>
      Two of the grammar-trees in this parser (<i>arr</i> and <i>obj</i>) use a <i>RepSep</i> 
      node -- something not many parser enthusiasts know. 
      For more details see <a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>.
    </p>

  </body>
</html>