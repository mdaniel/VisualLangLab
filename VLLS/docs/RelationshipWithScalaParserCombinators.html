<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Relationship with Scala Parser Combinators</title>
    <meta name="description" content="VisualLangLab's Relationship with Scala Parser Combinators" />
  </head>

  <body>
    <h1>VisualLangLab - Relationship with Scala Parser Combinators</h1>

<table border="1" style="border: 1px solid red;" width="100%"><tr><td>
<span style="font-size: larger;">For Ver-10.10 or higher only!</span><br/>
If you are using an older version, follow 
<a href="RelationshipWithScalaParserCombinators-legacy.html">this tutorial</a> instead. 
Beginning Ver-10.01, the title bar of the <i>About VisualLangLab</i> 
dialog box displays the version number. 
The latest jar file can be downloaded here: 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a>. 
</td></tr></table>

<p>
Parsers produced by VisualLangLab are based on the <a href="http://en.wikipedia.org/wiki/Parser_combinator">parser combinator</a> principle, and the implementation used is inspired by the design of classes in the Scala API's <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/package.html">combinator</a> package (with changes needed to suit the Java language and the GUI-IDE environment). 
</p>

<h2 id="CombinatorClasses">Combinator Classes</h2>

<p>
The class diagram in Figure-1 below shows the organization of VisualLangLab's parser combinator classes, and how the GUI uses them. The design of <code>Parsers</code>, <code>Parser</code>, <code>RegexParsers</code>, and <code>PackratParsers</code> is based on corresponding classes in the Scala API (respectively <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">Parsers</a>, <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a>, <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a>, and <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/PackratParsers.html">PackratParsers</a>). 
</p>

<p>
<img src="images/RelationshipWithScalaParserCombinators.png" alt="Class diagram relating VisualLangLab with Scala classes" /><br />
<i>Figure-1. Class diagram relating VisualLangLab with Scala classes</i>
</p>

<p>
The class <code>SimpleLexingRegexParsers</code> is however unique to VisualLangLab, and is its built-in <a href="http://en.wikipedia.org/wiki/Lexical_analysis">lexical analyzer</a> (or just <i>lexer</i>). The built-in lexer improves upon the very simple functionality of <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a>' <code>literal()</code> and <code>regex()</code> functions, and provides characteristics similar to those seen in full-fledged lexers.
</p> 

<h2 id="BuiltInLexer">Built-In Lexer</h2>

<p>
VisualLangLab's built-in lexer has the following characteristics:
</p> 

<ul style="list-style-type: disc;">
  <li>literal tokens take precedence over regex tokens, so if a literal and a regex match some input, the lexer will return the literal not the regex. This is useful for creating <i>reserved keywords</i></li>
  <li>the token that matches the longest piece of input always wins. Literals have precedence over regexs (previous rule) only when the matched lengths are equal</li>
  <li>there are not <i>scoped</i> tokens, but a workaround (see below) can be used in most situations requiring them</li>
  <li>all tokens, literals and regexs, have to be declared before use. Tokens are defined as described in <a href="EditingTheGrammarTree.html#CreatingTokens">Creating Tokens</a></li>
</ul>

<p>
The parser and test-run shown in Figure-2 below illustrate these ideas. The rule-tree shown contains a <i>Choice</i> element that attempts to match its input to one of the following tokens:
</p> 

<ul style="list-style-type: disc;">
  <li>the literal <i>and</i></li>
  <li>the literal <i>android</i></li>
  <li>the regex <i>\\d+</i> (a number)</li>
  <li>the regex <i>[a-z][a-z0-9]*</i> (an identifier)</li>
</ul>

<p>
The <i>Choice</i> element has a multiplicity of <i>1 or more</i>, and we run it (see <a href="TestingParsers.html#ValidationIsEasy">Validation Is Easy</a>) against the following input: <code>and123 android123 and 123 android 123</code>. As the text under <i>Parser Log</i> shows, the words in the input match the expected tokens (the log format is explained in <a href="ASTAndActionCode.html#ASTStructure">AST Structure</a>).
</p> 

<p>
<img src="images/lexer-characteristics.png" alt="Class diagram relating VisualLangLab with Scala classes" /><br />
<i>Figure-2. Built-in lexer characteristics</i>
</p>

<p>
The corresponding Scala parser created with <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a> would behave in a different way. That parser would break up words like <i>and123</i> and <i>android123</i> into two separate tokens (<i>and</i> or <i>android</i> respectively followed by <i>123</i>). This can be solved by using a parser based on <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html">JavaTokenParsers</a> instead of <i>RegexParsers</i>.
</p>

<p>
The built-in lexer's characteristics shown above are independent of the ordering of the tokens within the <i>Choice</i> element as demonstrated in Figure-3 below. The regex <i>[a-z][a-z0-9]*</i> has, in this case, been moved up to be the choice element's first child node.
</p> 

<p>
<img src="images/lexer-characteristics2.png" alt="Class diagram relating VisualLangLab with Scala classes" /><br />
<i>Figure-3. Ordering of tokens in choice</i>
</p>

<p>
Again, a Scala parser created with <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a> would interpret the inputs <i>and</i> and <i>android</i> as instances of the regex <i>[a-z][a-z0-9]*</i>, not as the corresponding literal tokens.
</p>

<h3 id="TokenScopes">Token Scopes</h3>

<p>
The built-in lexer does not support scoped tokens, and all tokens exist in a single global scope. However most scoping needs can be served by a rudimentary, sledgehammer-strength mechanism: ending a token's name with an underscore (_) places it in its own private scope. When the parser tests for such a token, the lexer does not come into play, so any other token definitions (in the global scope and other private scopes) are not considered. In effect, the lexer falls back to using the <code>literal()</code> and <code>regex()</code> methods of <code>RegexParsers</code> for these tokens.
</p> 

<h3 id="WhitspaceAndComments">Whitespace and Comments</h3>

<p>
The lexer depends on <code>RegexParsers</code>'s standard mechanism for handling whitespace. The regular expression passed to it is, however, created from the two separate specifications for whitespace and comments (see <a href="EditingTheGrammarTree.html#WhitespaceAndComments">Whitespace and Comments</a>). 
</p> 

<h3>Miscellaneous</h3>

<p>
The focus at this time is on functionality, so the performance of the lexer 
is not the best possible. Future versions will improve the design and performance 
of the lexer. 
</p> 

<p>
The builtin lexer has no dependencies on any other component of VisualLangLab, 
and may be used separately if required. 
</p> 

  </body>
</html>
