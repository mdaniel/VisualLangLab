<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>A Quick Tour</title>
  <meta name="description" content="A quick tour" />
</head>
 
<body>

<h1 id="AQuickTour">VisualLangLab - A Quick Tour</h1>

<p>
This tutorial uses <a href="http://vll.java.net/">VisualLangLab</a> to explore 
the scenarios and examples in chapter 3 (<i>A Quick Tour for the Impatient</i>) of the book 
<a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">
The Definitive ANTLR Reference</a>. 
The grammars used can be found online at this link: 
<a href="http://pragprog.com/titles/tpantlr/source_code">
http://pragprog.com/titles/tpantlr/source_code</a>
</p>

<table border="1" style="border: 1px solid red;" width="100%"><tr><td>
<span style="font-size: larger;">For Ver-10.10 or higher only!</span><br/>
If you are using an older version, follow 
<a href="a-quick-tour-legacy.html">this tutorial</a> instead. 
Beginning Ver-10.01, the title bar of the <i>About VisualLangLab</i> 
dialog box displays the version number. 
The latest jar file can be downloaded here: 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a>. 
</td></tr></table>

<p>
This tutorial is not a feature comparison of the two tools. 
It merely uses a familiar scenario (for many parsing-tool users) 
to illustrate the use of VisualLangLab. 
The suitability of VisualLangLab for any particular application 
must be evaluated from the documentation and examples at the 
<a href="http://vll.java.net/">VisualLangLab website</a>.  
</p>

<p>
The following list describes some essential jargon.
</p>

<ul style="list-style-type: disc;">
  <li><u>parser-rule (or just <i>rule</i>)</u>: a grammar rule such as those 
      in a <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> or 
      <a href="http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">EBNF</a> 
      grammar specification used for parser-generation tools</li>
  <li><u>rule-tree</u>: the graphical tree-structured display of a grammar-rule 
      on the left side of the VisualLangLab GUI</li>
  <li><u>saved-grammar</u>: An XML file containing a grammar specification 
      produced ("File" -> "Save" from main menu) or used ("File" -> "Open" from main menu) 
      by VisualLangLab</li>
</ul>

<p>
The only thing you need to follow this tutorial is the VisualLangLab JAR file 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a>. 
VisualLangLab is started by double-clicking <i>VLL4J.jar</i>. 
No other software or tool is needed. 
</p>

<h2 id="RecognizerForLanguageSyntax">Recognizer for Language Syntax</h2>

<p>
This part of the tutorial describes VisualLangLab equivalents of section 3.1 
(titled <i>Recognizing Language Syntax</i>) of 
<a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">
The Definitive ANTLR Reference</a>. The description below shows how to create 
the parser from scratch, but you can also inspect the complete parser by just 
invoking "Help" -> "Sample grammars" -> "TDAR-Expr" from the main menu 
as shown on the right side of Figure-1 below. 
</p>

<p id="Figure1">
  <img src="images/renaming-main-prog.png" alt="Renaming Main to prog" /><br />
  <i>Figure-1. Renaming "Main" to "prog"</i>
</p>

<h3 id="RuleProg">Rule 'prog'</h3>

<p>
VisualLangLab creates a parser-rule (or <i>grammar-tree</i>) called <i>Main</i> at startup. 
You can create the grammar-rule <i>prog</i> by just renaming <i>Main</i>. 
Click the toolbar's <i>Rename rule</i> 
button (<img src="../images/ToolBarButtonRenameRule.gif" alt="The reference icon" 
align="center" />) and enter <i>prog</i> into the dialog presented (lower left of Figure-1). 
The rule's name will be changed in the toolbar's dropdown list as well 
at the rule-tree's root icon (see Figure-2 below). 
</p>

<p>
The parser-rule <i>prog</i> is defined as follows.
</p>

<pre><code>prog: stat+ ;</code></pre>

<p>
So we must create the grammar-rule <i>stat</i> before we can complete <i>prog</i>. 
Click the <i>New rule</i> button (<img src="../images/ToolBarButtonNewRule.gif" 
alt="The reference icon" align="center" />), 
and enter <i>stat</i> into the dialog presented (left of Figure-2). 
After the new rule has been created, click the <i>back</i> button 
or select <i>stat</i> from the toolbar's drop-down list 
(see right side of Figure-2) to return to <i>prog</i>. 
</p>

<p id="Figure2">
  <img src="images/creating-stat.png" alt="Creating rule 'stat'" /><br />
  <i>Figure-2. Creating rule 'stat'</i>
</p>

<p>
Right-click the root-node of <i>prog</i>, and select <i>Reference</i> 
(left of Figure-3 below). Select <i>stat</i> from the dropdown list of the 
dialog presented, and click the <i>OK</i> button. The rule should now look 
like that on the right side of Figure-3. Right-click the newly added 
reference node (<img src="../images/GrammarIconReference.gif" alt="The reference icon" 
align="center" />), and select "Multiplicity" -> "+ (1 or more)" from the context menu. 
A "+" sign next to the reference icon indicates that the multiplicity has been changed 
(red circled at bottom right of Figure-3).
</p>

<p id="Figure3">
  <img src="images/populating-prog.png" alt="Populating rule 'prog'" /><br />
  <i>Figure-3. Populating rule 'prog'</i>
</p>

<h3 id="RuleStat">Rule 'stat'</h3>

<p>
The grammar-rule <i>stat</i> was already created above, and we populate the rule here 
using its complete definition shown below.
</p>

<pre><code>stat: expr NEWLINE
| ID '=' expr NEWLINE
| NEWLINE
;</code></pre>

<p>
At the topmost level, the rule is a choice of three structures (or <i>sub-rules</i>). 
Right-click the root-node (<img src="../images/GrammarIconRoot.gif" 
alt="The reference icon" align="center" />), and select "Add" -> "Choice" 
from the context menu (as at the top left of Figure-4 below). This should add 
a choice icon (<img src="../images/GrammarIconChoice.gif" alt="The choice icon" align="center" />)
to the root node (bottom left of Figure-4). 
Now right-click the newly created choice node (<img src="../images/GrammarIconChoice.gif" 
alt="The reference icon" align="center" />), and select "Add" -> "Sequence" 
from the context menu (as at the top right of Figure-4). This should add 
a sequence icon (<img src="../images/GrammarIconSequence.gif" alt="The choice icon" 
align="center" />) to the choice node. Repeat this action once more, so you have two 
sequence icons attached to the choice node (bottom right of Figure-4).
</p>

<p id="Figure4">
  <img src="images/populating-stat.png" alt="Populating rule 'stat'" /><br />
  <i>Figure-4. Populating rule 'stat'</i>
</p>

<p>
The little red "x" marks at the top-right of some icons is an error indicator. 
The tool-tip text (displayed when the mouse hovers over an icon) tells you 
what the problem is.
</p>

<p>
Before you can proceed further, you need to create the entities (tokens and rules) that 
<i>stat</i> uses. First create another parser-rule named <i>expr</i> following the 
instructions used to create <i>stat</i> described around <a href="#Figure2">Figure-2</a> above. 
Use the toolbar's dropdown list or the <i>Back</i> button (<img src="../images/ToolBarButtonBack.gif" 
alt="The choice icon" align="center" />) as described before to display 
the <i>stat</i> parser-rule again (as in bottom right of Figure-4 above). 
</p>

<p>
Next, create the tokens needed. Click the <i>New regex</i> toolbar button 
(<img src="../images/ToolBarButtonNewRegex.gif" alt="The choice icon" align="center" />), 
enter "<code>NEWLINE&nbsp;&nbsp;\\r?\\n</code>" into the dialog presented 
(right of Figure-5 below), and click the <i>OK</i> button. 
The text entered into the dialog contains the token's name and regular-expression 
pattern separated by one or more spaces. The name is used to refer to the token in 
parser-rules, while the pattern describes the input text that it may match. 
The pattern provided follows the same rules as <a href="">Java Patterns</a>, 
and must be written as if in a String in a Java program (hence the double backslash). 
</p>

<p>
Now, create two more regex tokens (named <i>INT</i> and <i>ID</i>) 
by following the same procedure, but entering the 
following texts into the dialog: "<code>INT&nbsp;&nbsp;\\d+</code>" and 
"<code>ID&nbsp;&nbsp;[a-zA-Z]+</code>". These are not shown in Figure-5.
</p>

<p id="Figure5">
  <img src="images/stat-tokens.png" alt="Creating tokens for 'stat'" /><br />
  <i>Figure-5. Creating tokens for 'stat'</i>
</p>

<p>
Then create a literal token by clicking the <i>New literal</i> toolbar button 
(<img src="../images/ToolBarButtonNewLiteral.gif" alt="The choice icon" align="center" />), 
enter "<code>EQUALS&nbsp;&nbsp;=</code>" into the dialog (left of Figure-5 above), 
and click the <i>OK</i> button. The pattern used for a literal token is just a literal, 
not a regular-expression. 
</p>

<p>
<u>Important</u>: The original PEG script does not have 
a token definition for "=" as it is used directly as an <i>inline-defined literal token</i>. 
VisualLangLab does not allow such inline anonymous token definitions, so all tokens must 
be named and defined.
</p>

<p>
You can now complete the <i>stat</i> parser-rule. Right-click the first sequence icon, 
and select "Add" -> "Reference" from the context menu. Select rule <i>expr</i> in the 
dialog presented, and click the <i>OK</i> button. Right-click the same sequence icon again 
and select "Add" -> "Token" from the context menu. Select token <i>NEWLINE</i> in the 
dialog presented, and click the <i>OK</i> button. Your parser-rule should now look like the one 
on the right side of Figure-6 below. 
</p>

<p id="Figure6">
  <img src="images/stat-completion-one.png" alt="Completing (1) rule 'stat'" /><br />
  <i>Figure-6. Completing (1) rule 'stat'</i>
</p>

<p>
Now select the second sequence icon, and add the following entities to it: The token 
<i>ID</i>, the token <i>EQUALS</i>, the reference <i>expr</i>, and the token <i>NEWLINE</i>. 
Now right-click the choice icon (just below the root), and add the token <i>NEWLINE</i>. 
Your parser-rule should now look like the one on the left side of Figure-7 below. 
This parser-rule is structurally similar to the original ANTLR parser-rule, although 
its behavior may differ somewhat in certain situations. 
Alternative sub-rules in VisualLangLab should ideally be arranged with the most 
specific ones near the top. So click the lower (second) sequence icon and drag it 
upwards above the upper (first) sequence icon. 
Your parser-rule should now look like the one on the right side of Figure-7. 
This is the complete <i>stat</i> rule.
</p>

<p id="Figure7">
  <img src="images/stat-completion-two.png" alt="Completing (2) rule 'stat'" /><br />
  <i>Figure-7. Completing (2) rule 'stat'</i>
</p>

<h3 id="RuleExpr">Rule 'expr'</h3>

<p>
The rule <i>expr</i> has already been created above, so you only have to populate 
the logic. The rule's EBNF specification is shown below.
</p>

<pre><code>expr: multExpr (('+' |'-' ) multExpr)* ;</code></pre>

<p>
Most things you need to know about parser-rule editing has been covered above, so 
we won't go into the details except to note a few prerequisites you need to complete 
before proceeding: create the parser-rule <i>multExpr</i>, and the literal tokens 
<i>PLUS</i> (with pattern "+") and <i>MINUS</i> (with pattern "-"). 
The original PEG script does not have these token definitions as it uses them as 
anonymous inline tokens.
When you've finished adding all elements to the parser-rule, it should look like the 
one on the left of Figure-8 below. 
</p>

<p id="Figure8">
  <img src="images/expr-completion.png" alt="Completing rule 'expr'" /><br />
  <i>Figure-8. Completing rule 'expr'</i>
</p>

<p>
The one last thing you need to do is set the multiplicity of the inner sequence icon to 
"*" (zero or more). Right-click the inner sequence icon, and select "Multiplicity" -> 
"*(0 or more)" from the context menu (as shown on the left). 
The multiplicity of the element changes from "1" to "*" (near red arrow). 
The finished parser-rule is on the right of Figure-8. 
</p>

<h3 id="RuleMultExpr">Rule 'multExpr'</h3>

<p>
The rule <i>multExpr</i> has already been created above, so you only have to populate 
the logic. The rule's EBNF specification is shown below.
</p>

<pre><code>multExpr: atom ('*' atom)* ;</code></pre>

<p>
It should be obvious that the parser-rule <i>atom</i>, and a literal token <i>MULT</i> 
(with pattern "*") must be created before proceeding. 
The finished parser-rule should look like the one in Figure-9 below. 
</p>

<p id="Figure9">
  <img src="images/multExpr-completion.png" alt="Completing rule 'multExpr'" /><br />
  <i>Figure-9. Completing rule 'multExpr'</i>
</p>

<h3 id="RuleAtom">Rule 'atom'</h3>

<p>
The rule <i>atom</i> has already been created above, so you only have to populate 
the logic. The rule's EBNF specification is shown below.
</p>

<pre><code>atom: INT
| ID
| '(' expr ')'
;</code></pre>

<p>
There are a few prerequisites this time too: literal tokens 
named <i>INT</i> (with pattern "\\d+"), <i>LPAREN</i> (with pattern "(") and 
<i>RPAREN</i> (with pattern ")"). The finished parser-rule should look like the one in 
Figure-10 below. 
</p>

<p id="Figure10">
  <img src="images/atom-completion.png" alt="Completing rule 'atomExpr'" /><br />
  <i>Figure-10. Completing rule 'atomExpr'</i>
</p>

<h3 id="WhitespaceSpecification">Whitespace Specification</h3>

<p>
In VisualLangLab whitespace is specified 
as a global parameter that you can inspect and modify as shown in Figure-11 below. 
Selecting "Globals" -> "Whitespace" brings up a dialog with the default whitespace 
regular-expression ("<code>\\s+</code>"). You should change the value to 
"<code>[ \\t]+</code>" (without the quote marks) and click the <i>OK</i> button. 
</p>

<p id="Figure11">
  <img src="images/whitespace.png" alt="Specifying whitespace" /><br />
  <i>Figure-11. Specifying whitespace</i>
</p>

<h3 id="WhatDoesVisualLangLabRGenerate">What Does VisualLangLab Generate?</h3>

<p>
VisualLangLab does not generate any code, and you don't have to compile any code 
to run a parser produced by it. VisualLangLab uses a Java version of 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">
Scala parser combinators</a> to turn the tree-models of the parser-rules <u>directly</u> 
into a parser at run-time without generating or compiling code. The intuitiveness, 
speed, and hassle-free nature of this approach is a huge advantage particularly when 
performing <a href="http://en.wikipedia.org/wiki/Ad_hoc_testing">ad hoc testing</a>. 
</p>

<p>
A VisualLangLab grammar can be saved to a file using the "File" -> "Save" menu or 
corresponding toolbar buttons. The saved grammar is a XML representation 
of the information entered into the GUI, but has no <i>generated</i> information 
or artifacts not provided by the user. A saved grammar file can be opened 
using the "File" -> "Open" menu (or corresponding toolbar buttons) for review, 
further editing, testing, etc. 
</p>

<p>
A saved grammar can also be loaded and turned into a parser by a client program via the 
<a href="../UsingTheAPI.html">VisualLangLab API</a>. Client programs can be written in any 
language (existing or yet-to-be-invented) that runs on the 
<a href="http://en.wikipedia.org/wiki/JVM">JVM</a>. 
</p>

<h3 id="TestingTheParser">Testing the Parser</h3>

<p>
VisualLangLab brings new meaning to the terms 
<a href="http://en.wikipedia.org/wiki/Ad_hoc_testing">Ad Hoc Testing</a> and 
<a href="http://en.wikipedia.org/wiki/Test-driven_development">Test-Driven Development</a>. 
No other parser-development tool simplifies testing so much. 
So, without further ado let's just perform the first test in the book:
</p>

<ul style="list-style-type: disc;">
  <li>Select <i>prog</i> from the toolbar's dropdown list as that is the 
      top-level parser-rule (or the <i>entry point</i>)</li>
  <li>Type the test input "<code>(3+4)*5</code>" (without quotes) into the text area under 
      <i>Parser Test Input</i>. <u>Remember to add a newline at the end</u></li>
  <li>Click the <i>Parse input</i> button (in red box)</li>
  <li>Inspect and verify the parser's output in the text area under <i>Parser Log</i>. 
      (VisualLangLab produces and prints out an AST on every successful parse)</li>
</ul>

<p>
Figure-12 below highlights the elements referred above, and shows the state of the 
GUI after the test. 
</p>

<p id="Figure12">
  <img src="images/test-one.png" alt="Performing test 1" /><br />
  <i>Figure-12. Performing test 1</i>
</p>

<p>
A VisualLangLab parser without actions spews out the 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> 
produced by the top-level parser-rule, and that is the text under 
<i>Parser Test Input</i> near the bottom of the GUI. 
You may assume that this output is correct as any parsing error 
would produce red text (as in <a href="#Figure13">Figure-13</a> below). 
Details about VisualLangLab's AST structure can be found in 
<a href="../ASTAndActionCode.html">AST And Action Code</a>.
</p>

<p>
If you see error messages or find other problems, verify the following:
</p>

<ul style="list-style-type: disc;">
  <li>That the test-input string "<code>(3+4)*5</code>" has a newline character at its end 
      (see bottom left of Figure-12 above)</li>
  <li>That your parser-rules (prog, stat, expr, multExpr, and atom) look like those 
      in figures 3 (bottom right), 7 (right side), 8 (right side), 9, and 10 respectively</li>
  <li>That the tokens have the patterns shown in the table below. You can edit 
      token patterns by selecting "Tokens" -> "Edit token" from the main menu</li>
  <li>That the <a href="#WhitespaceSpecification">whitespace regular-expression is set</a> to "<code>[ \\t]+</code>" 
      (without the quote marks)</li>
</ul>

<table border="1" style="border: 1px solid black;">
<tr><th align="center" colspan="3">Token Definitions</th></tr>
<tr><th align="center">Name</th><th align="center">Type</th><th align="center">Pattern</th></tr>
<tr><td align="center">EQUALS</td><td align="center">Literal</td><td align="center">=</td></tr>
<tr><td align="center">ID</td><td align="center">Regex</td><td align="center">[a-zA-Z]+</td></tr>
<tr><td align="center">INT</td><td align="center">Regex</td><td align="center">\\d+</td></tr>
<tr><td align="center">LPAREN</td><td align="center">Literal</td><td align="center">(</td></tr>
<tr><td align="center">MINUS</td><td align="center">Literal</td><td align="center">-</td></tr>
<tr><td align="center">MULT</td><td align="center">Literal</td><td align="center">*</td></tr>
<tr><td align="center">NEWLINE</td><td align="center">Regex</td><td align="center">\\r?\\n</td></tr>
<tr><td align="center">PLUS</td><td align="center">Literal</td><td align="center">+</td></tr>
<tr><td align="center">RPAREN</td><td align="center">Literal</td><td align="center">)</td></tr>
</table>

<p>
The results of a few more tests are shown in Figure-13 below. In all cases, ensure that 
the test-input string is terminated with a newline character (the text cursor must be 
on the next line as in Figure-12 above). VisualLangLab's error messages are in the 
nature of a stack-trace, showing (from top to bottom) the nesting of rules at the 
time of the failure. VisualLangLab does not implement automatic error recovery, 
but supports mechanisms that can be used to issue application-specific error messages, 
and recover from errors in predictable ways.
</p>

<p id="Figure13">
  <img src="images/test-two.png" alt="Test two" /><br />
  <img src="images/test-three.png" alt="Test three" /><br />
  <i>Figure-13. Testing error cases</i>
</p>

<h2 id="SyntaxDrivenActionExecution">Syntax Driven Action Execution</h2>

<p>
This part of the tutorial describes VisualLangLab equivalents of section 3.2 
(titled <i>Using Syntax to Drive Action Execution</i>) of 
<a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">
The Definitive ANTLR Reference</a>. 
The description below shows how to add action code to the parser created above, 
but you can also inspect the end result by just invoking 
"Help" -> "Sample grammars" -> "TDAR-Expr-Actions" from the main menu. 
The tutorial explains the use of action code within VisualLangLab, 
but you can learn more details at 
<a href="../ASTAndActionCode.html#ActionCodeDesign">Action Code Design</a>. 
</p>

<h3 id="ActionCodeBasics">Action Code Basics</h3>

<p>
Action code in VisualLangLab is written not as a <i>code snippet</i> 
but as an complete <a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a> 
function. Here are the main concepts:
</p>

<ul style="list-style-type: disc;">
  <li>an action code function can be associated with any parser-tree node except the root</li>
  <li>the function takes one argument</li>
  <li>the function is called twice: first before the associated parser-rule node is 
      parsed (the argument is then <i>null</i>), and second when 
      (and only if) the node is successfully parsed 
      (the argument then carries the resulting AST)</li>
  <li>the function should process the AST as needed, and return the processed 
      value which then becomes part of the higher-level containing AST</li>
  <li>an action function has no access to the parser's lexical environment except via 
      certain <a href="../ASTAndActionCode.html#PredefinedVariables">predefined variables</a></li>
</ul>

<p>
The structure of the AST for any parser-rule node is displayed in the panel next to the 
rule-tree (under <i>Parse Tree (AST) Structure</i>). The following 
examples should clarify these ideas. 
</p>

<p>
The ASTs passed to JavaScript action-code functions contain native JVM types (arrays, 
Lists, etc.). Users must be aware that all primitive types placed in arrays or Lists 
will have been auto-boxed (on the Java side) before being passed to JavaScript. 
The action-code functions must therefore explicitly unbox primitive types contained 
in arrays and Lists within ASTs.
</p>

<h3 id="ActionForProg">Action for 'prog'</h3>

<p>
Figure-14 below shows the rule-tree and AST for the parser-rule <i>prog</i> as well as 
certain details of the action code assignment process. The action is associated with 
the reference node, so that node must be selected to display the action-code function. 
To assign the action-code to the rule-tree created previously, proceed as follows: 
</p>

<ul style="list-style-type: disc;">
  <li>use the toolbar's drop-down list to select the parser-rule <i>prog</i></li>
  <li>select (click on) the reference icon that points to <i>stat</i></li>
  <li>type or paste (copy the code from the box below) the code into the text area 
      under <i>Action Code</i></li>
  <li>click the <i>Save</i> button under the text area. (The button becomes enabled 
      when the contents of the text area are changed)</li>
  <li>The dialog shown at lower left should appear, click its <i>OK</i> button. 
      An action code indicator flag should appear next to the reference icon</li>
</ul>

<p>
If there are any syntax errors in the action-code text, a dialog box indicating the 
error is displayed on clicking the <i>Save</i> button. 
</p>

<p id="Figure14">
  <img src="images/actions-prog.png" alt="Action for rule 'prog'" /><br />
  <i>Figure-14. Action for rule 'prog'</i>
</p>

<p>
Here is the action code for 'prog' that you can copy to paste into VisualLangLab's 
<i>Action Code</i> text area. 
</p>

<table border="1" style="border: 1px solid black;"><tr><td>
<pre><code>function (arg) {
  if (!arg) {
    memory = {};
  } else {
    return "Ok";
  }
}</code></pre>
</td></tr></table>

<p>
In effect, this is a package of two code snippets ...
</p>

<pre><code>memory = {};</code></pre>

<p>
... which is executed before parsing begins, 
and ...
</p>

<pre><code>return "Ok";</code></pre>

<p>
... which is executed after parsing ends. The first snippet (<code>memory = {};</code>) is therefore 
functionally equivalent to the line <code>HashMap memory = new HashMap();</code> in the original ANTLR parser. 
The second snippet (<code>return "Ok";</code>) 
subverts VisualLangLab's default action of passing the AST up the call chain. This causes VisualLangLab to 
print just the string <i>Ok</i> instead of the entire AST after parsing is complete. 
</p>

<h3 id="ActionForStat">Action for 'stat'</h3>

<p>
Figure-15 below shows the rule-tree and AST for parser-rule 
<i>stat</i> as well as the JavaScript function to be used as its action code. 
The action-code is associated with the choice node just below the root node, 
so that node must be selected to display the action-code function. 
</p>

<p id="Figure15">
  <img src="images/actions-stat.png" alt="Action for rule 'stat'" /><br />
  <i>Figure-15. Action for rule 'stat'</i>
</p>

<p>
The AST in Figure-15 uses certain features that are explained below. 
</p>

<ul style="list-style-type: disc;">
  <li>a name prefixed with an <i>@</i> sign represents the 
      value (or AST) returned by the parser-rule with the corresponding name. 
      Thus <i>@expr</i> is the value returned by parser-rule <i>expr</i></li>
  <li>a name within square brackets <i>[...]</i> represents the lexeme 
      matching the token with the corresponding name. 
      Thus <i>[ID]</i> is the lexeme matching the token <i>ID</i></li>
</ul>

<p>
The function in Figure-15 actually replaces three snippets of action code (the 
last one being a no-op). Separate functions could have been written to 
handle each case too. The option chosen here has the advantage of 
keeping all code for each parser-rule in one function.
</p>

<p>
The text of the action-code for this parser-rule is given below. 
</p>

<table border="1" style="border: 1px solid black;"><tr>
<td><pre><code>function (arg) {
  if (arg) {
    switch (arg[0].intValue()) {
      case 0: 
        memory[arg[1][0]] = arg[1][2].doubleValue(); 
        break;
      case 1:
        println(arg[1][0]); break;
      case 2: break;
    }
    return arg; 
  }
}</code></pre></td>
</tr></table>


<p>
If you're still wondering why the <code>intValue()</code> and <code>doubleValue()</code> calls 
are required, here's the secret: Since the argument to the function is (in this case) 
an array of Java <code>Object</code>s, all primitive Java types are autoboxed. So a Java 
<code>int</code> and <code>double</code> become a <code>java.lang.Integer</code> and 
<code>java.lang.Double</code> respectively, and JavaScript has to extract the original 
values using <code>intValue()</code> and <code>doubleValue()</code> explicitly as it 
does not know about <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html">auto unboxing</a>. 
</p>

<h3 id="ActionForAtom">Action for 'atom'</h3>

<p>
Figure-16 below shows the rule-tree and AST for parser-rule 
<i>atom</i> as well as the JavaScript function to be used as its action code. 
The action-code is associated with the choice node just below the root node, 
so that node must be selected to display the action-code function. 
</p>

<p id="Figure16">
  <img src="images/actions-atom.png" alt="Action for rule 'atom'" /><br />
  <i>Figure-16. Action for rule 'atom'</i>
</p>

<p>
The function in Figure-16 replaces three snippets of action code. 
Again, separate functions could have been written and associated with each 
of the three sub-nodes of the choice icon, but using one function has the 
advantage of keeping everything in one place.
</p>

<p>
The text of the action-code function for the parser-rule is shown below. 
</p>

<table border="1" style="border: 1px solid black;"><tr>
<td><pre><code>function (arg) {
  if (arg) {
    switch (arg[0].intValue()) {
      case 0: 
        return parseInt(arg[1]); 
      case 1:
        if (memory.hasOwnProperty(arg[1])) {
          return memory[arg[1]]; 
        } else {
          println("undefined variable " +
              arg[1]);
          return 0;
        }
      case 2: 
        return arg[1][1].doubleValue(); 
    }
  }
}</code></pre></td>
</tr></table>


<h3 id="ActionForMultExpr">Action for 'multExpr'</h3>

<p>
Figure-17 below shows the rule-tree and AST for parser-rule 
<i>multExpr</i> as well as the function to be used as its action code. 
The action-code is associated with the sequence node just below the root node, 
so that node must be selected to display the action-code function. 
</p>

<p id="Figure17">
  <img src="images/actions-multExpr.png" alt="Action for rule 'multExpr'" /><br />
  <i>Figure-17. Action for rule 'multExpr'</i>
</p>

<p>
The text of the action-code function for the parser-rule is shown below. 
Observe that the keyword <i>function</i> has been abbreviated to just <i>f</i>. 
Any prefix of the word <i>function</i> may be used as an abbreviation here.
</p>

<table border="1" style="border: 1px solid black;"><tr>
<td><pre><code>f (arg) {
  if (arg) {
    var atom = arg[0].doubleValue();
    var list = arg[1];
    for (var i = 0; i < list.size(); ++i) {
      var arr = list.get(i);
      atom *= arr[1].doubleValue();
    }
    return atom;
  }
}
</code></pre></td>
</tr></table>

<h3 id="ActionForExpr">Action for 'expr'</h3>

<p>
Figure-18 below shows the rule-tree and AST for parser-rule 
<i>expr</i> as well as the function to be used as its action code. 
The action-code is associated with the sequence node just below the root node, 
so that node must be selected to display the action-code function. 
</p>

<p id="Figure18">
  <img src="images/actions-expr.png" alt="Action for rule 'expr'" /><br />
  <i>Figure-18. Action for rule 'expr'</i>
</p>

<p>
The text of the action-code function for the parser-rule is shown below. 
</p>

<table border="1" style="border: 1px solid black;"><tr>
<td><pre><code>f (arg) {
  if (arg) {
    var multExpr = arg[0].doubleValue();
    var list = arg[1];
    for (var i = 0; i < list.size(); ++i) {
      var arr = list.get(i);
      var choice = arr[0][0].intValue();
      switch (choice) {
        case 0: multExpr += arr[1].doubleValue(); break;
        case 1: multExpr -= arr[1].doubleValue(); break;
      }
    }
    return multExpr;
  }
}
</code></pre></td>
</tr></table>

<h3 id="TestingTheActionCode">Testing the Action Code</h3>

<p>
As before, you can test the augmented parser right away (see Figure-19 below). 
Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>select <i>Prog</i> in the toolbar's dropdown list</li>
  <li>enter the test input string into the text area under <i>Parser Test Input</i>. 
      <u>Remember to end the string with a final NEWLINE (use the ENTER or RETURN key)</u></li>
  <li>click the <i>Parse input</i> button. The result appears in the text area under 
      <i>Parser Log</i></li>
</ul>

<p id="Figure19">
  <img src="images/test-action-one.png" alt="Testing the action code" /><br />
  <i>Figure-19. Testing the action code</i>
</p>

<h3 id="SavingGrammarWithActionCode">Saving Grammar with Action Code</h3>

<p>
A grammar with embedded actions can be saved ("File" -> "Save") and 
opened again ("File" -> "Open") with VisualLangLab's main menu operations 
just like any other grammar. The code is saved as text (source code) within the XML file. 
</p>

<h2 id="EvaluatingExpressionsUsingAnAST">Evaluating Expressions Using an AST</h2>

<p>
This part of the tutorial describes VisualLangLab equivalents of section 3.3 
(titled <i>Evaluating Expressions Using an AST Intermediate Form</i>) of 
<a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">
The Definitive ANTLR Reference</a>. 
</p>

<p>
VisualLangLab differs from most other parser-generators in that it always produces 
an AST. A <a href="../ASTAndActionCode.html#ASTStructure">well-defined convention</a> 
determines the structure of the AST, and the user does not have to do anything more. 
The argument passed to an action code function (as in the examples above) is in fact 
an AST for the associated grammar-tree node produced using the same 
<a href="../ASTAndActionCode.html#ASTStructure">structuring convention</a>.
</p>

<p>
An AST-based approach is designed for use in a client program that 
launches the parser, obtains the AST, and then interprets the AST or 
processes it into another form. VisualLangLab supports such operation 
via the <a href="../UsingTheAPI.html">VisualLangLab API</a> that enables a client program 
to regenerate a parser from a saved grammar. 
</p>

<h3 id="AGrammarForBuildingASTs">A Grammar for Building ASTs</h3>

<p>
As described above, a VisualLangLab parser always produces an AST, so you do not 
have to do anything special for this. But the default AST often contains 
many tokens that the application does not need, and dropping  
them makes the AST compact, less sensitive to small grammar changes, and more usable. 
The following description uses a grammar obtained by dropping all disposable AST parts 
from the grammar described in 
<a href="#RecognizingLanguageSyntax">Recognizing Language Syntax</a> above. 
</p>

<p>
The <i>stat</i> parser-rule shown in Figure-20 below is a good example of a 
rule with parts that may be <i>drop</i>ped. To drop (from the AST) a part of 
a rule, right-click the node and select <i>Drop</i> from the context menu 
as on the left side of Figure-20. The icon of a dropped node has a slanted 
line drawn across its icon and the <i>drop</i> attribute added. The right 
side of Figure-20 shows the <i>stat</i> rule with several tokens dropped. 
</p>

<p id="Figure20">
  <img src="images/drop-stat-one.png" alt="Dropping part of an AST" /><br />
  <i>Figure-20. </i>Drop<i>ping part of an AST</i>
</p>

<p>
To inspect a version of this grammar with all disposable parts dropped, select 
"Help" -> "Sample grammars" -> "TDAR-Expr-AST" from the main menu. 
</p>

<h3 id="EvaluatingASTEncodedExpressions">Evaluating AST-Encoded Expressions</h3>

<p>
This section shows you how to embed and use a VisualLangLab parser in an 
application program. To compile and run the code below proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>for compilation and running, the working directory as well as <i>VLL4J.jar</i> 
      must be on the classpath</li>
  <li>when running, the saved-grammar file (named <i>TDAR-Expr-AST.vll</i>) must be in the 
      working directory. You get this file by selecting "Help" -> "Sample grammars" 
      -> "TDAR-Expr-AST" from the main menu, and then saving ("File" -> "Save As") 
      the grammar to a file of that name. Remember to save the file to the right directory</li>
</ul>

<p>
The text parsed and interpreted by the program is in the first line of 
<code>main()</code>. You can change the contents of that line to check out 
the parser fully. The red and blue parts of the code below are dependent on the 
<a href="../UsingTheAPI.html">VisualLangLab API</a>. The blue parts follow 
naming and usage conventions based on Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">parser combinators</a>. 
There is one function dedicated to handling each rule (e.g. function <i>atomHdlr</i> for rule <i>atom</i>, 
function <i>multExprHdlr</i> for rule <i>multExpr</i>, etc.). So comparing the code of each 
such funcion with the AST structure of the corresponding rule is easy. It is possible to 
write the application program in any JVM language using principles 
explained in  <a href="../UsingTheAPI.html">Using the API</a>. 
</p>

<pre><code>import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import <span style="color:red; font-weight: bold">vll4j.Vll4j</span>;

public class TDARExprAST {

    static float evalAtom(Object ast) {
        Object pair[] = (Object[])ast;
        switch ((Integer)pair[0]) {
            case 0: 
                return Float.parseFloat((String)pair[1]);
            case 1: 
                if (memory.containsKey(pair[1])) {
                    return memory.get(pair[1]);
                }
                else {
                    System.out.printf("Undefined variable: %s%n", pair[1]); 
                    return 0;
                }
            case 2: return evalExpr(pair[1]);
        }
        return 0; /* never used, keeps compiler happy */
    }
    
    static float evalMultExpr(Object ast) {
        Object arr[] = (Object[])ast;
        Float res = evalAtom(arr[0]);
        List&lt;Object[]> lst = (List&lt;Object[]>)arr[1];
        for (Object pair[]: lst) {
            res *= evalAtom(pair[1]);
        }
        return res;
    }
    
    static float evalExpr(Object ast) {
        Object arr[] = (Object[])ast;
        Float res = evalMultExpr(arr[0]);
        List&lt;Object[]> lst = (List&lt;Object[]>)arr[1];
        for (Object pair[]: lst) {
            Object discr[] = (Object[])pair[0];
            switch ((Integer)discr[0]) {
                case 0: res += evalMultExpr(pair[1]); break;
                case 1: res -= evalMultExpr(pair[1]); break;
            }
        }
        return res;
    }
    
    static void evalStat(Object ast) {
        Object pair[] = (Object[])ast;
        switch ((Integer)pair[0]) {
            case 0: 
                Object arr[] = (Object[])pair[1];
                String id = (String)arr[0];
                Float res = evalExpr(arr[1]);
                memory.put(id, res);
                break;
            case 1: 
                System.out.println(evalExpr(pair[1])); 
                break;
            case 2: /*do nothing*/ 
                break;
        }
    }
    
    static void evalProg(Object ast) {
        List listOfStat = (List)ast;
        for (Object stat: listOfStat) {
            evalStat(stat);
        }
    }
    
    static Map&lt;String, Float> memory = new HashMap&lt;String, Float>();

    public static void main(String[] args) throws ParserConfigurationException, 
            SAXException, IOException {
        String input = "a=3\nb=4\n2+a*b\n";
        <span style="color:red; font-weight: bold">Vll4j</span> vll = <span style="color:red; font-weight: bold">Vll4j.fromFile</span>(new File("TDAR-Expr-AST.vll"));
        Vll4j.Parser exprParser = vll.getParserFor("Prog");
        <span style="color:blue; font-weight: bold">Vll4j.ParseResult</span> parseResult = vll.<span style="color:blue; font-weight: bold">parseAll</span>(exprParser, input);
        if (parseResult.<span style="color:blue; font-weight: bold">successful</span>()) {
            Object ast = parseResult.<span style="color:blue; font-weight: bold">get</span>();
            evalProg(ast);
        } else {
            System.out.println(parseResult);
        }
    }
}</code></pre>

<h2 id="ASimpleTreeBasedInterpreter">A Simple Tree-Based Interpreter</h2>

<p>
The content of this section is a parser described on the 
<a href="http://www.antlr.org/wiki/display/ANTLR3/Simple+tree-based+interpeter">
ANTLR site wiki</a>. The book refers to this parser at the very end of section 3.3 
(see footnote on page 84). It expands on the grammar discussed above, and adds the 
following features:
</p>

<ul style="list-style-type: disc;">
  <li>adds divide and modulo operations to the <i>multExpr</i> rule</li>
  <li>adds user-defined functions (with limitations)</li>
</ul>

<p>
The following discussion shows how to create an interpreter using two different approaches: 
processing the AST with an action attached to the top-level rule, and in an application 
program via the <a href="../UsingTheAPI.html">VisualLangLab API</a>. 
</p>

<h3 id="InterpreterInActionCode">Interpreter in Action Code</h3>

<p>
The grammar for this application (including the action code) is bundled with VisualLangLab. 
Select "Help" -> "Sample grammars" -> "TDAR-Simple-Tree-Based-Interpreter" from the main 
menu. 
The action code is associated with the reference node (labeled <i>stat</i>) 
of the top-level rule (<i>Prog</i>), and is displayed when the reference node is selected 
(as in Figure-21 below). 
</p>

<p>
<u>Note</u>: The relative position of some of the alternative branches in some of the rules have 
been altered to arrange them in order of specificity. The interpreter also uses JavaScript's 
native numeric type for computations instead of BigDecimal (as in the original example code).
The rules are otherwise unchanged. 
</p>

<p id="Figure21">
  <img src="images/tree-based-interpreter.png" alt="Interpreter in action code" /><br />
  <i>Figure-21. Interpreter in action code</i>
</p>

<p>
Figure-21 also shows the execution a few lines of <i>code</i> that include 
a definition and use of the <i>factorial</i> function. 
</p>

<h3 id="InterpreterInClojureProgram">Interpreter in Clojure Program</h3>

<p>
Coming soon!
</p>

</body>
</html>