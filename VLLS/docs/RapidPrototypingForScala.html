<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http:/Action-PaycheckTester/www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
  <head>
    <title>VisualLangLab - Rapid Prototyping for Scala Parser Combinators (Java version)</title>
    <meta name="description" content="Rapid Prototyping for Scala Parser Combinators with VisualLangLab (Java version)" />
  </head>

  <body>

<h1>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</h1>

<table border="1" style="border: 1px solid red;" width="100%"><tr><td>
<span style="font-size: larger;">For Ver-10.10 or higher only!</span><br/>
If you are using an older version, follow 
<a href="RapidPrototypingForScala-legacy.html">this tutorial</a> instead. 
Beginning Ver-10.01, the title bar of the <i>About VisualLangLab</i> 
dialog box displays the version number. 
The latest jar file can be downloaded here: 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a>. 
</td></tr></table>

<p>
This tutorial highlights 
<a href="http://vll.java.net/">VisualLangLab</a>'s features by recreating the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar" target="_blank">
Payroll External DSL</a> described on page 240 of 
<a href="http://programmingscala.com/" target="_blank">Programming Scala</a>. 
The following figures show how it represents some rules of that parser. 
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
    <th style="text-align: center; font-weight: bold;">amount</th>
    <th style="text-align: center; font-weight: bold;">days</th>
    <th style="text-align: center; font-weight: bold;">deductItems</th>
    <th style="text-align: center; font-weight: bold;">deductKind</th>
  </tr>
  <tr>
    <td style="padding: 0em;"><img src="images/amount.png" alt="The amount grammar" /></td>
    <td style="padding: 0em;"><img src="images/days.png" alt="The days grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductItems.png" alt="The deductItems grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductKind.png" alt="The deductKind grammar" /></td>
  </tr>
</tbody></table>
<i>Figure-1. Some VisualLangLab grammar-trees</i>

<p>
Earlier versions (before 10) of VisualLangLab were written in Scala, and made use of its 
<a href="http://www.scala-lang.org/api/current/index.html#scala.util.parsing.combinator.package">
parser combinators</a>. Although version 10 
is written purely in Java it still uses Java translations of certain elements of the 
Scala <code>scala.util.parsing.combinator</code> package. 
A comparison between this approach and hand-coded Scala parsers can be found in 
<a href="#ProsAndCons">Pros and Cons</a> below.
</p>

<p>
Another tutorial that uses examples from 
<a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">
The Definitive ANTLR Reference</a> 
can be found in <a href="http://vll.java.net/examples/a-quick-tour.html">A Quick Tour</a>.
A simpler tutorial is available at  
<a href="http://today.java.net/article/2011/09/14/visuallanglab-grammar-without-tears" target="_blank">
VisualLangLab - Grammar without Tears</a>.
</p>

<h3 id="EssentialJargon">Essential Jargon</h3>

<ul style="list-style-type: disc;">
  <li><i>parser</i> (with lower-case inital <i>p</i>) - in <a href="http://vll.java.net/">VisualLangLab</a> documentation, 
    a parser is an <i>entire</i> program or function for 
    <a href="http://en.wikipedia.org/wiki/Parsing#Parser" target="_blank">parsing and processing input</a> 
     in a certain format. </li>
  <li><i>parser-rule</i> - the 
    <a href="http://en.wikipedia.org/wiki/Formation_rule" target="_blank">simpler units</a> 
    into which a parser is normally broken down. 
    In a Scala combinator-based parser, each <code>def ... : Parser[...] = ...</code> 
    is a parser-rule. Parser-rule and grammar-tree are generally synonymous terms.</li>
  <li><i>grammar-tree</i> - the visual tree used to represent each parser-rule 
    in <a href="http://vll.java.net/">VisualLangLab</a>. Grammar-tree and 
    parser-rule are generally synonymous terms.</li>
  <li><i>Parser</i> (with upper-case inital <i>P</i>) - a 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank">Scala type</a> used to 
    implement <i>parser-rule</i>s as well as the component nodes of parser-rules</li>
</ul>

<p>
Version 10 is written in Java, and does not use Scala parser combinators. However, it 
still uses Java translations of some elements of the <code>scala.util.parsing.combinator</code> 
package. In that sense, VisualLangLab is still a <i>Scala combinator-based parser</i>.
</p>

<h2>Download and Run VisualLangLab</h2>

<p>
To run <a href="http://vll.java.net/">VisualLangLab</a>, just download 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a> 
and double-click it in a file-browser. Linux, Mac OS, and UNIX users will have to enable execution first 
(<i>chmod +x VLL4J.jar</i>). 
Documentation for version 10 and higher is currently on the web-site only.
</p>

<p>
When started, <a href="http://vll.java.net/">VisualLangLab</a> displays the GUI shown in Figure-2 below. 
The menus and buttons are explained as needed, but a full 
description can also be found at 
<a href="TheGUI.html" target="_blank">The GUI</a>. 
All toolbar buttons have tool-tip texts that explain their use. 
</p>

<p>
<img src="images/GuiFull3.png" alt="The VisualLangLab GUI" /><br />
<i>Figure-2. The VisualLangLab GUI</i>
</p>

<p>
The display areas of the GUI are used as described below.
</p>

<ul style="list-style-type: disc;">
  <li>A is used for the grammar-tree as described in 
      <a href="#CreatingParserRules">Creating the Parser-Rules</a> below</li>
  <li>B displays the <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST structure</a> 
      of the selected grammar-tree node</li>
  <li>C is where the selected node's <a href="#ActionCode">action-code</a> 
      (<i>semantic action</i>, or just <i>action</i>) is displayed and edited. 
      If this appears to break the 
      <i>no code, no script</i> promise, rest assured that action-code 
      is always optional</li>
  <li>D and E are used for <a href="#Testing">testing the parser</a> 
      as described below</li>
</ul>

<p>
The only prerequisite for running <a href="http://vll.java.net/">VisualLangLab</a> as described above is a 
<a href="http://www.oracle.com/technetwork/java/javase/overview/index-jsp-136246.html" target="_blank">6.0+ JRE</a>. 
No other tool or software is required.</p>

<h2 id="CreatingParserRules">Creating the Parser-Rules</h2>

<p>
In the book, the parser-rules are organized in top-down fashion. 
But here, we start at the bottom with <i>doubleNumber</i>, and work our way up, 
creating some of the parser-rules so as to demonstrate most of 
<a href="http://vll.java.net/">VisualLangLab</a>'s features. The complete parser is also 
included as a sample parser within the GUI (select "Help" -> "Sample grammers" ->
"PSWP-Payroll-Parser-Combinators" from the main menu).
</p>

<h3>Import Required Tokens</h3>

<p>
The book's code starts by importing 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">JavaTokenParsers</a> 
and you can obtain the same effect in <a href="http://vll.java.net/">VisualLangLab</a> 
by importing the corresponding <i>token library</i>. 
Select <i>Tokens -> Import tokens</i> from the main menu, or click the <i>Import tokens</i> 
(<img src="images/Import16.gif" align="center" alt="The import-tokens GUI" />) button, and choose the file 
<i>TL-JavaTokenParsers.vll</i> from the the <i>grammars</i> directory of the 
<a href="http://java.net/projects/vll/downloads/download/VLLS.zip">
legacy-version zip distribution</a> (you do not need any other files from this zip file). 
This token-library contains <i>regex</i> tokens with the same names and functionality. 
However, for reasons explained in <a href="#JavaTokenParsers">JavaTokenParsers</a> 
below, all the names have an underscore (_) suffix. 
</p>

<h3 id="DefDoubleNumber">def doubleNumber = floatingPointNumber ...</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=UCbbvJDoIpI">See it on YouTube</a>
</p>-->

<p>
This is a very simple parser-rule, and just matches one token unconditionally. 
To create the new rule click the <i>New rule</i> button 
(<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
and enter <i>doubleNumber</i> into the dialog box presented as in Figure-3 below. 
Clicking the dialog's <i>OK</i> button creates a new rule with just a 
<i>Root</i> node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />).
</p>

<p>
<img src="images/CreateRule-doubleNumber.png" alt="Creating the doubleNumber parser-rule" /><br />
<i>Figure-3. Creating the </i>doubleNumber<i> parser-rule</i>
</p>

<p>
Now right-click the Root node, and select <i>Add -> Token</i> from the popup 
context-menu. Another dialog with the names of available tokens is presented 
as shown on the left side of Figure-4 below. 
Select <i>floatingPointNumber_</i> and click the <i>OK</i> button. Your almost-complete 
parser-rule should look like the right side of Figure-4 below. 
</p>

<p>
<img src="images/AddToken-decimalNumber.png" alt="Selecting the decimalNumber token" /><br />
<i>Figure-4. Selecting the </i>decimalNumber<i> token</i>
</p>

<p>
Finally, we need to add some action-code. Select (click) the <i>decimalNumber</i> token 
(<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), 
and paste the code 
given below into the text area under <i>Action Code</i> as in Figure-5 
below. Click the <i>Save</i> button (enabled when the content of the action-code area 
changes). Observe that this adds the <i>action</i> annotation 
(near red arrow) to the <i>decimalNumber</i> token. From version 10.21, the rule-name 
(<i>doubleNumber</i>) in the toolbar's dropdown list also has a small green arrow-icon 
placed near it. 
</p>

<pre><code>function (a) {
  if (a) {
    return parseFloat(a);
  }
}</code></pre>

<p>
Action-code functions are explained further in <a href="#ActionCode">Action Code</a> below. 
</p>

<p>
<img src="images/Action-doubleNumber.png" alt="Adding action-code to the doubleNumber rule" /><br />
<i>Figure-5. Adding action-code to the </i>doubleNumber<i> rule</i>
</p>

<h3>def toBe = "is" | "are"</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=2aIodvLeCVw">See it on YouTube</a>
</p>-->

<p>
This parser-rule uses two custom literal tokens (<i>is</i> and <i>are</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New literal</i> button 
    (the <img src="images/ToolBarButtonNewLiteral.gif" align="center" alt="The New-literal button" /> icon), 
    enter "<code>IS  is</code>" into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-6 below)</li>
  <li>repeat the preceding action once more, but enter "<code>ARE  are</code>" instead</li>
</ul>

<p>
The information entered into the dialog when creating a literal contains the 
literal's <i>name</i>, and its <i>pattern</i> separated by a comma.
You can optionally add spaces around the comma for clarity if required. 
The <i>name</i> is used to refer to the literal in rules (as 
seen in <a href="#Figure7">Figure-7</a> below), while the <i>pattern</i> is it's literal definition. 
</p>

<p>
<img src="images/NewLiteral-IsAre.png" alt="Creating the is and are tokens" /><br />
<i>Figure-6. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
This parser-rule uses a <i>Choice</i> 
(the <img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" /> icon) as its top-level node. 
A <i>Choice</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of the 
<i>|</i> combinator. But unlike <i>|</i> it accepts an arbitrary number (&gt;= 2) of 
child nodes, and returns an AST that remembers which child node matched the input 
(see <a href="#ActionCodeWeekDays">example below</a>). 
To create the parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-reference button" />), 
    enter <i>toBe</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) and select 
    <i>Add -> Choice</i> from the context menu. A <i>Choice</i> node 
    (<img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" />) is added to the root node
    (as in the left and middle parts of Figure-7 below)</li>
  <li>right-click the newly created choice node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is popped up. 
    Select <i>IS</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the prceding action, but select the token <i>ARE</i> instead</li>
</ul>

<p>
Your <i>toBe</i> parser-rule should now look like the one on the right side of Figure-7 below. 
</p>

<p id="Figure7">
<img src="images/CreateRule-toBe.png" alt="The toBe parser" /><br />
<i>Figure-7. The </i>toBe<i> parser</i>
</p>

<p>
The grammar-tree's node icons are designed to be intuitive, but you can find a 
guide to all the icons in 
<a href="EditingTheGrammarTree.html#GrammarTreeIconsAndAnnotations" target="_blank">
Grammar Tree Icons and Annotations</a>
</p>

<h3>def percentage = toBe ~> doubleNumber <~ "percent" <~ "of" <~ "gross" ...</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=43SUBPL_kF0">See it on YouTube</a>
</p>-->

<p>
This parser-rule uses a <i>Sequence</i> 
(the <img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" /> icon) 
as its top-level node. 
A <i>Sequence</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of 
the <i>~</i>, <i>&lt;~</i>, and <i>~&gt;</i> combinators. But unlike the <i>~</i> family, 
it accepts an arbitrary (non-zero) number of child nodes, 
and the AST returned is just a Java array which is much simpler to handle 
than a nested instance of <code>case class ~</code>. 
To create this parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>percentage</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) and select 
    <i>Add -> Sequence</i> from the context menu. A <i>Sequence</i> node 
    (<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />) is added to the root node</li>
  <li>right-click the newly created sequence node and select <i>Add -> Reference</i> from the context menu. 
    A dialog box with a dropdown list containing known parser-rule names is presented. 
    Select <i>toBe</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action once more, selecting the reference <i>doubleNumber</i> instead</li>
  <li>right-click the sequence node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is presented. 
    Select <i>PERCENT</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action two more times, and add the tokens <i>OF</i> 
    and <i>GROSS</i> to the sequence node</li>
</ul>

<p>
Examining the arrows (<i>~></i> and <i><~</i>) in the <code>def</code>inition, 
we can deduce that only the result of matching <i>doubleNumber</i> is desired to 
be retained. All other tokens are to be dropped from the AST. You can <i>drop</i> 
tokens from the sequence's AST by right-clicking each node's icon and selecting 
<i>drop</i> from the context menu (as shown on the left side of the figure). 
Remember not to <i>drop</i> the <i>doubleNumber</i> token. 
Your finished parser-rule should now look like the right side of Figure-8 below.
</p>

<p>
<img src="images/Rule-percentage.png" alt="The percentage parser-rule" /><br />
<i>Figure-8. The </i>percentage<i> parser-rule</i>
</p>

<p>
Observe that the icons of <i>drop</i>ped nodes are overlaid with a black line 
from the lower-left to the upper-right. The 
<a href="EditingTheGrammarTree.html#Annotations" target="_blank">annotation</a> <i>drop</i> is also added 
after the name of the node.
</p>

<p>
Finally, add the action-code: select (click) the <i>Sequence</i> icon 
(<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />), and paste the Javascript code 
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>function (arg) {
  if (arg !== null) {
    return VLL.grossAmount * (arg / 100);
  }
}</code></pre>

<p>
Though different from the original text, this action function is actually functionally 
equivalent, as explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one in Figure-8 above. 
</p>

<h3>def days = "days?".r ...</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=WFrv9UFcFWY">See it on YouTube</a>
</p>-->

<p>
This parser-rule uses a custom regex token (<i>days?</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New regex</i> button 
    (the <img src="images/ToolBarButtonNewRegex.gif" align="center" alt="The New-regex button" /> icon), 
    enter "<code>DAYS  days?</code>" into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-9 below). Here <i>days?</i> is a regular-expression 
    <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank">Pattern</a></li>
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>days</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center alt="The Root node" "/>) 
    and select <i>Add -> Token</i> from the context menu. 
    Select <i>DAYS</i> from the dropdown list, and click the <i>OK</i> button</li>
</ul>

<p>
<img src="images/NewRegex-days.png" alt="Creating the is and are tokens" /><br />
<i>Figure-9. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
Finally, add the action-code by selecting he <i>DAYS</i> icon 
(<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), 
and pasting the code  
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>function (a) {
  if (a) {
    return 1;
  }
}</code></pre>

<p>
Action-code function design and use is explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one on the right side of Figure-9 above. 
</p>

<h2 id="AdHocTesting">Ad Hoc Testing - A Short Detour</h2>

<p>
A <a href="#Testing">full section</a> on testing comes later, 
this section demonstrates the simplicity and power of <a href="http://vll.java.net/">VisualLangLab</a>'s 
manual testing facilities. It shows how you can effortlessly 
validate every little addition or change without using or learning 
any other skills or tools. 
</p>

<h3>Validating doubleNumber</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=UqhnQImB-jY">See it on YouTube</a>
</p>-->

<p>
To manually test <i>doubleNumber</i> proceed as follows. Use the toolbar's combo box 
to select <i>doubleNumber</i> as in Figure-10 below.
</p>

<ul style="list-style-type: disc;">
  <li>enter test input under <i>Parser Test Input</i> 
    (red rectangle at bottom left)</li> 
  <li>click the <i>Parse input</i> button (<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />)</li> 
  <li>validate the parser's result printed under <i>Parser Log</i> 
    (wide red rectangle at bottom right)</li> 
</ul>

<p>
If you do not see any red text (as in <a href="#Figure12">Figure-12</a> below) in the 
<i>Parser Log</i> area, your parser executed without errors. 
But that alone is not enough, you should verify that the result returned 
(the <i>25</i> in Figure-10, for example) is the value expected. 
</p>

<p>
<img src="images/testing-doubleNumber.png" alt="Testing the doubleNumber parser" /><br />
<i>Figure-10. Testing the </i>doubleNumber<i> parser</i>
</p>

<p>
The parser's <i>result</i> or AST is on the third line (after the <i>result follows:</i>). 
The previous two lines of output contain performance 
information that should be ignored. 
This test passes as <i>25</i> (last line under <i>Parser Log</i>) is the expected 
result. 
</p>

<h3>Validating toBe</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=89MQBpXKNlE">See it on YouTube</a>
</p>-->

<p>
Before you start to enter test data for <i>toBe</i> take a moment to understand 
the structure of its output. All parser-rules return an 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">abstract syntax tree</a> (or AST) 
whose structure depends on the arrangement and properties of the grammar-tree's constituent nodes 
as explained in <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a>. 
The text area under <i>Parse Tree (AST) Structure</i> displays the expected AST 
structure of the selected grammar-tree node. Figure-11 below tells you that the returned 
result is one of two array objects (depending on what was found in the input). 
</p>

<p>
<img src="images/AST-toBe.png" alt="The AST of the toBe parser-rule" /><br />
<i>Figure-11. The AST of the </i>toBe<i> parser-rule</i>
</p>

<p id="Figure12">
Figure-12 below shows the result of exercising <i>toBe</i> with three different 
inputs: <i>is</i>, <i>are</i>, and <i>other</i>. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-is.png" alt="The AST of toBe with is" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-are.png" alt="The AST of toBe with are" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-other.png" alt="The AST of toBe with other" /></td></tr>
  <tr><td style="padding: 2px"><i>Figure-12. Validating </i>toBe<i> with different inputs</i></td></tr>
</table>

<p>
This set of tests too pass as all three test cases produce the expected result. 
</p>

<h2>The Remaining Parser-Rules</h2>

<p>
The remaining parser-rules, except one that uses a <code>repsep</code> and 
is described fully below, present no new difficulties and 
we leave them as an exercise for the reader. 
You can verify your creation by comparing it with the saved-grammar file 
<i>payroll-parser-comb.vll</i> in the <i>grammars</i> directory of the zip distribution. 
</p>

<h3>def deductItems = repsep(deductItem, ",")</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=hyTeuBskfIo">See it on YouTube</a>
</p>-->

<p>
This parser-rule uses a <i>RepSep</i> 
(the <img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" /> icon) as its top-level node. 
To create this rule proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>deductItems</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />) and select 
    <i>Add -> RepSep</i> from the context menu (as on the left side of Figure-13 below). 
    A <i>RepSep</i> node 
    (<img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" />) is added to the root node</li>
  <li>right-click the newly created RepSep node and select <i>Reference</i> from the context menu. 
    A dialog with known parser-rule names is presented. 
    Select <i>deductItem</i> from the dropdown, and click the <i>OK</i> button</li>
  <li>right-click the RepSep node again and select <i>Add -> Token</i> from the context menu. 
    Select <i>COMMA</i> from the dropdown, and click the <i>OK</i> button</li>
</ul>

<p>
Your finished rule should look like the one on the right side of Figure-13 below. 
</p>

<p>
<img src="images/Rule-deductItems.png" alt="The deductItems parser-rule" /><br />
<i>Figure-13. The </i>deductItems<i> parser-rule</i>
</p>

<h2 id="ActionCode">Action Code</h2>

<p>
Action-code is written as anonymous funtion literals in Javascript. 
You can find detailed guidelines at 
<a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">Action-Code Design</a>. 
</p>

<h3 id="ActionCodeWeekDays">Action-Code: weekDays</h3>

<p>
The purpose of <i>weekDays</i> is to check the input, and return the integer <i>5</i> if either 
<i>weeks</i> or <i>week</i> is found, and the integer <i>1</i> if <i>days</i> or <i>day</i> 
is found. As described in <a href="#ActionCode">Action Code</a> below, 
action-code functions must handle two cases: a <i>null</i> argument, and a non-null 
(<i>real</i> AST) argument. <i>weekDays</i>' action function only needs to handle the 
non-<i>null</i> argument case. 
(Of all the examples in this article, only the action-code in 
<a href="#WrapperWithActions">Wrapper with Actions</a> below needs to handle 
the <i>null</i>-argument case.)  
</p>

<p>
To understand the logic of the action-code you must 
know the structure of the AST passed in (as the argument <i>a</i>). 
The rule's AST structure is depicted in the text area under 
<i>Parse Tree (AST) Structure</i>. 
<a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a> describes 
AST structuring principles in general. 
</p>

<p>
<img src="images/Action-weekDays.png" alt="The weekDays action-code function" /><br />
<i>Figure-14. The weekDays action-code function</i>
</p>

<p>
The AST structure and action-code of the two subordinate rules used 
by <i>weekDays</i> (<i>weeks</i> and <i>days</i>) is shown in Figure-15 below. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/Action-weeks.png" alt="Action function weeks" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/Action-days.png" alt="Action function days" /></td></tr>
</table>
<i>Figure-15. Action functions of weeks and days rules</i>

<p>
Since <i>weekDays</i>' subordinate rules return the required values (5 and 1), 
its own action-code only needs to pass on the value recieved. Based on the 
above details we know that the AST passed in to <i>weekDays</i> is one of 
these two values: <code>Object[] {0,5}</code>, and <code>Object[] {1, 1}</code> (the 
second member of each array being the value from the subordinate rules). 
So <i>weekDays</i> merely needs to return the second member of the array. 
</p>

<h3 id="ActionCodePercentage">Action-Code: percentage</h3>

<p>
Figure-16 below illustrates the action-code associated with the rule <i>percentage</i>. 
This function uses a non-local reference <code>VLL.grossAmount</code>. 
As described in <a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">Action-Code Design</a>, 
the symbol <code>VLL</code> refers to a common global object available to all action-code 
functions, and should be used as a repository for all parser-specific features (methods and 
functions) and state (data). <a href="#WrapperWithActions">Wrapper with Actions</a> below 
illustrates how <code>VLL</code> is equipped with required features before 
testing begins. 
</p>

<p>
<img src="images/Action-percentage.png" alt="A Javascript action-code function" /><br />
<i>Figure-16. A Javascript action-code function</i>
</p>

<p>
The function does not have any setting-up role, so does not have to handle the 
<i>null</i>-argument case. The value of <code>arg</code> it receives is the 
output from the rule <i>doubleNumber</i> (see AST structure). 
It returns the computed percentage value. 
</p>

<h2 id="Testing">Testing</h2>

<p>
Testing is much simpler in <a href="http://vll.java.net/">VisualLangLab</a> than in virtually any other tool. 
<a href="#AdHocTesting">Ad Hoc Testing - A Short Detour</a> showed 
how effective ad hoc manual testing can be in certain situations. 
<a href="http://vll.java.net/">VisualLangLab</a> also supports automated testing, and the following  
sections describe two different approaches for different situations. 
</p>

<h3 id="WrapperWithActions">Wrapper with Actions</h3>

<p>
This approach uses an additional parser-rule to <i>wrap</i> the main 
(or top-level) parser-rule with <i>before</i> and <i>after</i> scripts.
The <i>before</i> script sets up initial conditions before the main 
parser-rule is invoked, and the <i>after</i> script validates the parse-tree 
returned by the main parser-rule. 
Figure-17 below shows details of the wrapper rule <i>PaycheckTester</i> used for testing this parser. 
To display the <i>before</i> and <i>after</i> scripts (actually 
parts of a single action-code function) you must select (click on)
the <i>Reference</i> node that points to the <i>Paycheck</i> parser-rule. 
From version 10.21 onwards, parser-rules designed for testing using this technique 
are automatically distinguished with a special icon in the toolbar's dropdown list.
</p>

<p>
<b>If you have not read <a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">
Action-Code Design</a> and <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a>, 
please do so now!</b>
</p>

<p>
<img src="images/Action-PaycheckTester.png" alt="Wrapper rule for automated testing" /><br />
<i>Figure-17. Wrapper rule for automated testing</i>
</p>

<p>
The Javascript function with the before and after scripts is reproduced below for clarity. 
The setup part of the function (<i>null</i>-argument part) performs two functions:
</p>

<ul style="list-style-type: disc;">
  <li>sets up the data-member <code>grossSalary</code>, and creates the 
    method <code>salaryForDays</code> in the global object <code>VLL</code>. 
    (Javascript's dynamic nature allows it to add data and function members 
    to existing objects at run-time)</li>
  <li>deposits a few lines of test input (from 
    <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_let_s_try_it_out_here_is_a_sp" target="_blank">here</a> in 
    the OFPS version of <i>Programming Scala</i>) into the <i>Parser Test Input</i> area. 
    These lines are processed as input when the main parser-rule (<i>Paycheck</i>) runs</li>
</ul>

<p>
The test part of the code checks the structure 
of the parse-tree returned by the main parser, and prints out an appropriate message. 
</p>

<pre><code>function (arg) {
  if (arg === null) {
//****************************************
//          SETUP actions
//****************************************
  // global variables and functions ...
    VLL = {};
    VLL.grossSalary = 500.0
    VLL.salaryForDays = function (days) {
      return VLL.grossSalary * days;
    }
  // Input text for parser ...
    vllParserTestInput.setText(
      "paycheck for employee \"Buck Trends\"\n" +
      "is salary for 2 weeks minus deductions for {\n" +
      "  federal income tax is 25. percent of gross,\n" +
      "  state income tax is 5. percent of gross,\n" +
      "  insurance premiums are 500. in gross currency,\n" +
      "  retirement fund contributions are 10. percent of gross\n" +
      "}"
    )
  } else {
//****************************************
//          TEST actions
//****************************************
    if (arg.length === 3) {
      var error = ""
      var empl = arg[0];
      if (!empl.equals("Buck Trends")) {
        error += "BAD empl (" + empl + "), ";
      }
      var gross = arg[1].doubleValue();
      if (gross !== 5000) {
        error += "BAD gross (" + gross + "), ";
      }
      var deduct = arg[2].doubleValue();
      if (deduct !== 2500) {
        error += "BAD deduct (" + deduct + "), ";
      }
      if (error === "") {
        return "OK";
      } else {
        return error;
      }
    } else {
      return "BAD AST structure";
    }
  }
}</code></pre>

<p>
To understand how this works, let's run it a few times with and 
without changes to the test input as in the table below. The red text is the 
changed part (in the table). To run the test after making changes 
in the action-code click the <i>Save</i> button and wait for 
a pop-up dialog to confirm that the change was accepted, click 
the pop-up's <i>OK</i> button, and then click the <i>Parse input</i> 
(<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />) button. 
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
    <th colspan="2" style="text-align: center; font-weight: bold;">Sample Inputs for Rule Paycheck</th>
  </tr>
  <tr>
    <th style="text-align: center; font-weight: bold;">Input</th>
    <th style="text-align: center; font-weight: bold;">Result</th>
  </tr>
  <tr>
    <td style="padding: 2px">No changes</td>
    <td style="padding: 2px">OK</td>
  </tr>
  <tr>
    <td style="padding: 2px">... employee &quot;<span style="color: red; font-weight: bold;">D</span>uck Trends&quot; ...</td>
    <td style="padding: 2px">BAD empl, </td>
  </tr>
  <tr>
    <td style="padding: 2px">... salary for 2<span style="color: red; font-weight: bold;">2</span> weeks minus ...</td>
    <td style="padding: 2px">BAD gross, BAD deduct,</td>
  </tr>
  <tr>
    <td style="padding: 2px">... premiums are <span style="color: red; font-weight: bold;">9</span>00. in ...</td>
    <td style="padding: 2px">BAD deduct</td>
  </tr>
</table>

<p>
Near the top of the script, a value called <i>ParserTestInput</i> is 
used. This name is a reference to the GUI's <code>JTextArea</code> 
from which the parser under test obtains input (and into 
which test input is normally entered manually). More information about 
this can be found under <a href="ASTAndActionCode.html#PredefinedVariables" target="_blank">
Predefined Variables</a>. 
</p>

<h2 id="RegexParsersCompatibility">Scala Parser Combinator Compatibility</h2>

<table border="1" style="border: 1px solid red;" width="100%"><tr><td>
The following discussion is no longer (version 10 onwards) accurate. 
However, the contents still have some relevance as VisualLangLab still 
uses a Java translation of some elements of the <code>scala.util.parsing.combinator</code> 
package. 
</td></tr></table>

<p>
The class diagram in Figure-18 below depicts 
<a href="http://vll.java.net/" target="_blank">VisualLangLab</a>'s relationship with Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/package.html" target="_blank">
parser combinators</a>. Although it depends on <code>RegexParsers</code>, it changes 
most of the functionality by overriding many of the important methods.
</p>

<p>
<img src="images/RelationshipWithScalaParserCombinators.png" alt="Relationship With Scala Parser Combinators" /><br />
<i>Figure-18. Relationship With Scala Parser Combinators</i>
</p>

<p>
Full details of how VisualLangLab uses Scala's parser combinator library can be seen in 
<a href="RelationshipWithScalaParserCombinators.html" target="_blank">
Relationship with Scala Parse rCombinators</a>. 
</p> 

<h3 id="BuiltinLexicalAnalyzer">Builtin Lexical Analyzer</h3>

<p>
VisualLangLab overrides the <code>literal(String)</code> and <code>regex(Regex)</code> methods 
of Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
RegexParsers</a> with versions that work with a built-in lexer. The behavior of these 
versions is similar to lexers in more sophisticated parser development tools, and is described in 
<a href="RelationshipWithScalaParserCombinators.html#ClassSimpleLexingRegexParsers" target="_blank">
Simple Lexing RegexParsers</a>. 
</p>

<h3 id="JavaTokenParsers">JavaTokenParsers</h3>

<p>
Many example parsers in tutorials and other resources extend 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">
JavaTokenParsers</a>, so VisualLangLab provides a token library in it's place. 
Those planning to use this token library should, however, note that the tokens defined in 
it have names ending in an underscore (_). Ending the name of a token in an underscore causes 
VisualLangLab's built-in lexer to be bypassed, in favor of the 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">RegexParsers</a> 
capability. 
</p>

<p>
This change is required because the builtin lexer works best when the regex 
definitions are distinct, and multiple regex tokens will not match the same lexeme. 
But the regular expressions used in 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">
JavaTokenParsers</a> are such that <code>floatingPointNumber</code> subsumes both <code>decimalNumber</code> 
and <code>wholeNumber</code>, and <code>decimalNumber</code> itself subsumes <code>wholeNumber</code>. 
</p>

<h2 id="ProsAndCons">Pros and Cons</h2>

<p>
The table below lists the pros and cons of using VisualLangLab compared with 
a hand-written parser based on Scala parser combinators.
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
      <th style="text-align: center; font-weight: bold;">Aspect</th>
      <th style="text-align: center; font-weight: bold;">Pros</th>
      <th style="text-align: center; font-weight: bold;">Cons</th>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="2" style="text-align: center; padding: 2px">Visual</td>
    <td style="padding: 2px">Completely visual. Code never required, except if semantic 
        predicates are used (but they are rare)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">All IDE functions provided - file, edit (tokens, rules, globals), test-run, input-output </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="5" style="text-align: center; padding: 2px">Lexical Analyzer</td>
    <td style="padding: 2px">The builtin lexer works like <a href="http://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">
        lexical analyzer generators</a>, but does not require any separate steps or tools</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Token definitions may use the full regular-expression language of the JDK's 
        <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank">Pattern</a></td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Unlike 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a>, all literal tokens are treated as <i>reserved keywords</i> that have higher priority 
        than regex tokens. The next lexeme provided by the lexer is always the longest possible part of the 
        input that matches any known token</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px"><a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a> compatible behavior can also be obtained if required</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Performance is probably poorer than 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a> though no measurements have been made</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">AST</td>
    <td style="padding: 2px">Defined and created automatically following a well-defined and documented 
        convention for AST structure. The AST is complete and unambiguous, and captures 
        every detail of how the input matched the grammar</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The AST is defined using common types from the Scala API, so no specialized 
        knowledge is needed when using AST from Scala. Programs in other JVM languages can obtain a 
        version of the AST constructed from JVM types only (release 6.01+). </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">All elements in the AST are amenable to Scala pattern matching, 
        so AST processing is simple. Programs in other JVM languages have to deal with a mutually 
        nested structure of arrays and lists. </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="4" style="text-align: center; padding: 2px">Action Code</td>
    <td style="padding: 2px">Completely separated from grammar text. Written as function literals 
        invoked in a well-defined and documented protocol. 
        Action code functions may access their environment via a defined and 
        documented set of predefined <i>global</i> variables.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Option of languages: Scala and Javascript</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Never required to be embedded in parser text</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Lexical context of the parser is not available to action code. 
        However, since this restricts the action-code to its own <i>sand-box</i> it can be 
        seen as an an advantage too. </td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="4" style="text-align: center; padding: 2px">RegexParsers Compatibility</td>
    <td style="padding: 2px">Provides token libraries for JavaTokenParsers</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr bgcolor="#dddddd">
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Defines two layers (SimpleLexingRegexParsers an Aggregates) 
        which value-add to RegexParsers's capabilities</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The usual RegexParses interface is exposed to API users</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Not directly compatible, and such code can not be generated</td>
  </tr>

  <tr>
    <td rowspan="4" style="text-align: center; padding: 2px">API</td>
    <td style="padding: 2px">Parser developed in the VisualLangLab IDE may be saved to a file, and 
        subsequently used from a host program via the API</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API usable from any JVM language (release 6.01+)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Parser does not have to be compiled or linked into host program.
        The parser can even be modified separately without affecting the host program 
        (provided the AST structure is not changed)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API based on the familiar RegexParsers interface for convenience</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">Testing</td>
    <td style="padding: 2px">Includes comprehensive builtin support for ad hoc testing. 
        No additional tools, code, or skills are required.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Test drivers for black-box testing are easily created and run within 
        the IDE</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Any (or all) rules can be trace-enabled at the click of a button. 
        Even individual grammar-tree nodes can be traced.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
</table>

  </body>
</html>
