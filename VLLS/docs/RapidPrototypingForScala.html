<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http:/Action-PaycheckTester/www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
  <head>
    <title>VisualLangLab - Rapid Prototyping for Scala Parser Combinators (Java version)</title>
    <meta name="description" content="Rapid Prototyping for Scala Parser Combinators with VisualLangLab (Java version)" />
  </head>

  <body>

<h1>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</h1>

<table border="1" style="border: 1px solid red;" width="100%"><tr><td>
<span style="font-size: larger;">For Ver-10.01 or higher only!</span><br/>
If you are using an older version, follow <a href="RapidPrototypingForScala-legacy.html">this tutorial</a> instead. Beginning Ver-10.01, the title bar of the <i>About VisualLangLab</i> dialog box displays the version number. The latest jar file can be downloaded here: 
<a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a>. 
</td></tr></table>

<p>
The title of this article is a vestige from the time (version 7.x) when VisualLangLab was written in Scala, and was effectively a rapid development environment for parsers created with Scala's <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/package.html">parser combinators</a>. The current version (10.xx) is written in pure Java, but retains a strong design <a href="RelationshipWithScalaParserCombinators.html">Relationship with Scala Parser Combinators</a>. Parsers created with the two technologies therefore have strong similarities, and VisualLangLab is still an effective exploratory tool for someone planning a parser written in Scala. A comparison of the two approaches can be found in <a href="#ProsAndCons">Pros and Cons</a> below.

</p>

<p>
This tutorial highlights 
<a href="http://vll.java.net/">VisualLangLab</a>'s features by recreating the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar">
Payroll External DSL</a> described on page 240 of 
<a href="http://programmingscala.com/">Programming Scala</a>. 
The following figures show how it represents some rules of that parser. 
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
    <th style="text-align: center; font-weight: bold;">amount</th>
    <th style="text-align: center; font-weight: bold;">days</th>
    <th style="text-align: center; font-weight: bold;">deductItems</th>
    <th style="text-align: center; font-weight: bold;">deductKind</th>
  </tr>
  <tr>
    <td style="padding: 0em;"><img src="images/amount.png" alt="The amount grammar" /></td>
    <td style="padding: 0em;"><img src="images/days.png" alt="The days grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductItems.png" alt="The deductItems grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductKind.png" alt="The deductKind grammar" /></td>
  </tr>
</tbody></table>
<i>Figure-1. Some VisualLangLab grammar-trees</i>

<p>
Another tutorial that uses examples from the book <a href="http://pragprog.com/book/tpantlr/the-definitive-antlr-reference">The Definitive ANTLR Reference</a> can be found in <a href="http://vll.java.net/examples/a-quick-tour.html">A Quick Tour</a>. A simpler tutorial is available at <a href="GrammarWithoutTears2/GrammarWithoutTears2.html">Grammar without Tears2</a>.
</p>

<h2>Download and Run VisualLangLab</h2>

<p>
To run VisualLangLab, just download <a href="http://java.net/projects/vll/downloads/download/VLL4J.jar">VLL4J.jar</a> and double-click it in a file-browser. Linux, Mac OS, and UNIX users may have to enable execution first (<i>chmod +x VLL4J.jar</i>). Alternatively, you can enter "<code>java -jar VLL4J.jar</code>" at a command prompt. 
</p>

<p>
When started, VisualLangLab displays the GUI shown in Figure-2 below. The menus and buttons are explained as needed, but a full description can also be found at <a href="TheGUI.html">The GUI</a>. All toolbar buttons have tool-tip texts that explain their use. 
</p>

<p>
<img src="images/GuiFull3.png" alt="The VisualLangLab GUI" /><br />
<i>Figure-2. The VisualLangLab GUI</i>
</p>

<p>
The display areas of the GUI are used as described below.
</p>

<ul style="list-style-type: disc;">
  <li>A is used for the grammar-tree as described in <a href="#CreatingParserRules">Creating the Parser-Rules</a> below</li>
  <li>B displays the <a href="ASTAndActionCode.html#ASTStructure">AST structure</a> of the selected grammar-tree node</li>
  <li>C is where the selected node's <a href="#ActionCode">action-code</a> (<i>semantic action</i>, or just <i>action</i>) is displayed and edited. If this appears to break the <i>no code, no script</i> promise, rest assured that action-code is always optional</li>
  <li>D and E are used for <a href="#Testing">testing the parser</a> as described below</li>
</ul>

<p>
The only prerequisite for running VisualLangLab as described above is a 6.0+ JRE</a>. No other tool or software is required.
</p>

<h2 id="CreatingParserRules">Creating the Parser-Rules</h2>

<p>
In the book (<a href="http://programmingscala.com/">Programming Scala</a>), the parser-rules are organized in top-down fashion. But here, we start at the bottom with <i>doubleNumber</i>, and work our way up, creating some of the parser-rules and demonstrating most of VisualLangLab's features. The complete parser is also included as a sample grammar within the GUI (select "Help" -> "Sample grammers" -> "PSWP-Payroll-Parser-Combinators" from the main menu).
</p>

<h3 id="ImportedElements">Imported Elements</h3>

<p>
The book's code starts by importing <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html">JavaTokenParsers</a>. VisualLangLab has no <i>JavaTokenParsers</i> equivalent, but we can simulate the effect of the <code>import</code> by creating three regex tokens (<i>decimalNumber</i>, <i>floatingPointNumber</i>, and <i>stringLiteral</i>). 
</p>

<p>
To create the token <i>decimalNumber</i> click the <i>New regex</i> toolbar button (<img src="images/ToolBarButtonNewRegex.gif" align="center" alt="The New-regex button" />), enter the text shown below into the dialog presented, and click the "OK" button as in Figure-3. Token creation is explained in greater detail in <a href="EditingTheGrammarTree.html#CreatingTokens">Creating Tokens</a>.
</p>

<pre><code>decimalNumber_&nbsp;&nbsp;(\\d+(\\.\\d*)?|\\d*\\.\\d+)</code></pre>

<p>
<img src="images/create-token-decimalNumber.png" alt="Creating token decimalNumber" /><br />
<i>Figure-3. Creating the </i>decimalNumber<i> token</i>
</p>

<p>
Repeat the same procedure twice more to create <i>floatingPointNumber</i> and <i>stringLiteral</i>. The strings to be entered into the <i>New regex</i> dialog are given below.
</p>

<pre><code>floatingPointNumber_  -?(\\d+(\\.\\d*)?|\\d*\\.\\d+)([eE][+-]?\\d+)?[fFdD]?
stringLiteral_  \"([^\"\\p{Cntrl}\\\\]|\\[\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*\"</code></pre>

<p>
Observer that in all three cases described above, an underscore (_) has been appended to the token name. The reason for this is explained at <a href="#BuiltinLexicalAnalyzer">Builtin Lexical Analyzer</a> below.
</p>

<h3 id="DefDoubleNumber">def doubleNumber = floatingPointNumber ...</h3>

<p>
This is a very simple parser-rule, and just matches one token unconditionally. 
To create the new rule click the <i>New rule</i> button 
(<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
and enter <i>doubleNumber</i> into the dialog box presented as in Figure-4 below. 
Clicking the dialog's <i>OK</i> button creates a new rule with just a 
<i>Root</i> node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />).
</p>

<p>
<img src="images/CreateRule-doubleNumber.png" alt="Creating the doubleNumber parser-rule" /><br />
<i>Figure-4. Creating the </i>doubleNumber<i> parser-rule</i>
</p>

<p>
Now right-click the Root node, and select <i>Add -> Token</i> from the popup 
context-menu. Another dialog with the names of available tokens is presented 
as shown on the left side of Figure-5 below. 
Select <i>floatingPointNumber_</i> and click the <i>OK</i> button. Your almost-complete 
parser-rule should look like the right side of Figure-5 below. 
</p>

<p>
<img src="images/AddToken-decimalNumber.png" alt="Selecting the decimalNumber token" /><br />
<i>Figure-5. Selecting the </i>floatingPointNumber_<i> token</i>
</p>

<p>
Finally, we need to add some action-code. Select (click) the <i>floatingPointNumber_</i> token (<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), and paste the code given below into the text area under <i>Action Code</i> as in Figure-6 below. Click the <i>Save</i> button (enabled when the content of the action-code area changes). Observe that this adds the <i>action</i> annotation (near red arrow) to the <i>floatingPontNumber_</i> token. The rule-name (<i>doubleNumber</i>) in the toolbar's dropdown list is also given a small green arrow-icon to indicate that the rule has an action function. 
</p>

<pre><code>function (a) {
  if (a) {
    return parseFloat(a);
  }
}</code></pre>

<p>
Action-code functions are explained further in <a href="#ActionCode">Action Code</a> below. 
</p>

<p>
<img src="images/Action-doubleNumber.png" alt="Adding action-code to the doubleNumber rule" /><br />
<i>Figure-6. Adding action-code to the </i>doubleNumber<i> rule</i>
</p>

<h3>def toBe = "is" | "are"</h3>

<p>
This parser-rule uses two custom literal tokens (<i>is</i> and <i>are</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New literal</i> button 
    (the <img src="images/ToolBarButtonNewLiteral.gif" align="center" alt="The New-literal button" /> icon), 
    enter "<code>is</code>" into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-7 below)</li>
  <li>repeat the preceding action once more, but enter "<code>are</code>" instead</li>
</ul>

<p>
The above actions create two literal tokens with names "is" and "are" respectively. 
These names will be used to refer to the tokens from rules as seen in 
<a href="#Figure8">Figure-8</a> below.
</p>

<p>
<img src="images/NewLiteral-IsAre.png" alt="Creating the is and are tokens" /><br />
<i>Figure-7. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
This parser-rule uses a <i>Choice</i> 
(the <img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" /> icon) as its top-level node. 
A <i>Choice</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of the 
<i>|</i> combinator. But unlike <i>|</i> it accepts an arbitrary number (&gt;= 2) of 
child nodes, and returns an AST that remembers which child node matched the input 
(see <a href="#ActionCodeWeekDays">example below</a>). 
To create the parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-reference button" />), 
    enter <i>toBe</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) of the new rule, and select <i>Add -> Choice</i> from the context menu. A <i>Choice</i> node (<img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" />) is added to the root node (as in the left and middle parts of Figure-8 below)</li>
  <li>right-click the newly created choice node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is popped up. 
    Select <i>"is"</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the prceding action, but select the token <i>"are"</i> instead</li>
</ul>

<p>
Your <i>toBe</i> parser-rule should now look like the one on the right side of Figure-8 below. 
</p>

<p id="Figure8">
<img src="images/CreateRule-toBe.png" alt="The toBe parser" /><br />
<i>Figure-8. The </i>toBe<i> parser</i>
</p>

<p>
The grammar-tree's node icons are designed to be intuitive, but you can find a 
guide to all the icons in 
<a href="EditingTheGrammarTree.html#GrammarTreeIconsAndAnnotations">
Grammar Tree Icons and Annotations</a>
</p>

<h3>def percentage = toBe ~> doubleNumber <~ "percent" <~ "of" <~ "gross" ...</h3>

<p>
This parser-rule uses a <i>Sequence</i> 
(the <img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" /> icon) 
as its top-level node. 
A <i>Sequence</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of 
the <i>~</i>, <i>&lt;~</i>, and <i>~&gt;</i> combinators. But unlike the <i>~</i> family, 
it accepts an arbitrary (non-zero) number of child nodes, 
and the AST returned is just a Java array which is much simpler to handle 
than a nested instance of <code>case class ~</code>. 
To create this parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>percentage</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) and select 
    <i>Add -> Sequence</i> from the context menu. A <i>Sequence</i> node 
    (<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />) is added to the root node</li>
  <li>right-click the newly created sequence node and select <i>Add -> Reference</i> from the context menu. A dialog box with a dropdown list containing known parser-rule names is presented. Select <i>toBe</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action once more, selecting the reference <i>doubleNumber</i> instead</li>
  <li>before proceeding further create literal tokens "percent", "of", and "gross"</li>
  <li>right-click the sequence node and select <i>Add -> Token</i> from the context menu. A dialog box with a dropdown list containing known token names is presented. Select <i>"percent"</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action two more times, and add the tokens <i>"of"</i> and <i>"gross"</i> to the sequence node</li>
</ul>

<p>
Examining the arrows (<i>~></i> and <i><~</i>) in the <code>def</code>inition, 
we can deduce that only the result of matching <i>doubleNumber</i> is desired to 
be retained. All other tokens are to be dropped from the AST. You can <i>drop</i> 
tokens from the sequence's AST by right-clicking each node's icon and selecting 
<i>drop</i> from the context menu (as shown on the left side of the figure). 
Remember not to <i>drop</i> the <i>doubleNumber</i> node. 
Your finished parser-rule should now look like the right side of Figure-9 below.
</p>

<p>
<img src="images/Rule-percentage.png" alt="The percentage parser-rule" /><br />
<i>Figure-9. The </i>percentage<i> parser-rule</i>
</p>

<p>
Observe that the icons of <i>drop</i>ped nodes are overlaid with a black line 
from the lower-left to the upper-right. The 
<a href="EditingTheGrammarTree.html#Annotations">annotation</a> <i>drop</i> is also added 
after the name of the node.
</p>

<p>
Finally, add the action-code: select (click) the <i>Sequence</i> icon 
(<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />), and paste the Javascript code 
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>function (arg) {
  if (arg !== null) {
    return VLL.grossAmount * (arg / 100);
  }
}</code></pre>

<p>
Though different from the original text, this action function is actually functionally 
equivalent, as explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one in Figure-9 above. 
</p>

<h3>def days = "days?".r ...</h3>

<p>
This parser-rule uses a custom regex token (<i>days?</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New regex</i> button 
    (the <img src="images/ToolBarButtonNewRegex.gif" align="center" alt="The New-regex button" /> icon), 
    enter "<code>DAYS  days?</code>" into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-10 below). Here <i>days?</i> is a regular-expression 
    <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" >Pattern</a></li>
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>days</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" "/>) 
    and select <i>Add -> Token</i> from the context menu. 
    Select <i>DAYS</i> from the dropdown list, and click the <i>OK</i> button</li>
</ul>

<p>
<img src="images/NewRegex-days.png" alt="Creating the is and are tokens" /><br />
<i>Figure-10. Creating the </i>DAYS<i> tokens</i>
</p>

<p>
Finally, add the action-code by selecting he <i>DAYS</i> icon 
(<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), 
and pasting the code  
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>function (a) {
  if (a) {
    return 1;
  }
}</code></pre>

<p>
Action-code function design and use is explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one on the right side of Figure-10 above. 
</p>

<h2 id="AdHocTesting">Ad Hoc Testing - A Short Detour</h2>

<p>
This section demonstrates the simplicity and power of <a href="http://vll.java.net/">VisualLangLab</a>'s 
manual testing facilities. It shows how you can effortlessly 
validate every little addition or change without using or learning 
any other skills or tools. 
</p>

<h3>Validating doubleNumber</h3>

<!--<p>
<a href="http://www.youtube.com/watch?v=UqhnQImB-jY">See it on YouTube</a>
</p>-->

<p>
To manually test <i>doubleNumber</i> proceed as follows. Use the toolbar's combo box 
to select <i>doubleNumber</i> as in Figure-11 below.
</p>

<ul style="list-style-type: disc;">
  <li>enter test input under <i>Parser Test Input</i> (bottom left)</li> 
  <li>click the <i>Parse input</i> button (<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />)</li> 
  <li>validate the parser's result printed under <i>Parser Log</i> (bottom right)</li> 
</ul>

<p>
If you do not see any red text (as in <a href="#Figure13">Figure-13</a> below) in the 
<i>Parser Log</i> area, your parser executed without errors. 
But that alone is not enough, you should verify that the result returned 
(the <i>25.0</i> in Figure-11, for example) is the value expected. 
</p>

<p>
<img src="images/testing-doubleNumber.png" alt="Testing the doubleNumber parser" /><br />
<i>Figure-11. Testing the </i>doubleNumber<i> parser</i>
</p>

<p>
This test passes as <i>25.0</i> is the expected result. 
</p>

<h3>Validating toBe</h3>

<p>
Before you start to enter test data for <i>toBe</i> take a moment to understand 
the structure of its output. All parser-rules return an 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" >abstract syntax tree</a> (or AST) 
whose structure depends on the arrangement and properties of the grammar-tree's constituent nodes 
as explained in <a href="ASTAndActionCode.html#ASTStructure" >AST Structure</a>. 
The text area under <i>Parse Tree (AST) Structure</i> displays the expected AST 
structure of the selected grammar-tree node. Figure-12 below tells you that the returned 
result is one of two array objects (depending on what was found in the input). 
</p>

<p>
<img src="images/AST-toBe.png" alt="The AST of the toBe parser-rule" /><br />
<i>Figure-12. The AST of the </i>toBe<i> parser-rule</i>
</p>

<p id="Figure13">
Figure-13 below shows the result of exercising <i>toBe</i> with three different 
inputs: <i>is</i>, <i>are</i>, and <i>other</i>. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-is.png" alt="The AST of toBe with is" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-are.png" alt="The AST of toBe with are" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-other.png" alt="The AST of toBe with other" /></td></tr>
  <tr><td style="padding: 2px"><i>Figure-13. Validating </i>toBe<i> with different inputs</i></td></tr>
</table>

<p>
This set of tests too pass as all three test cases produce the expected result. 
</p>

<h2>The Remaining Parser-Rules</h2>

<p>
The remaining parser-rules, except one that uses a <code>repsep</code> and is described fully below, present no new difficulties and we leave them as an exercise for the reader. You can verify the parser you create by comparing it with the bundled sample grammar  (select "Help" -> "Sample grammers" -> "PSWP-Payroll-Parser-Combinators" from the main menu). 
</p>

<h3>def deductItems = repsep(deductItem, ",")</h3>

<p>
This parser-rule uses a <i>RepSep</i> 
(the <img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" /> icon) as its top-level node. 
To create this rule proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>deductItems</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />) and select 
    <i>Add -> RepSep</i> from the context menu (as on the left side of Figure-14 below). 
    A <i>RepSep</i> node 
    (<img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" />) is added to the root node</li>
  <li>right-click the newly created RepSep node and select <i>Reference</i> from the context menu. 
    A dialog with known parser-rule names is presented. 
    Select <i>deductItem</i> from the dropdown, and click the <i>OK</i> button</li>
  <li>right-click the RepSep node again and select <i>Add -> Token</i> from the context menu. 
    Select <i>","</i> from the dropdown, and click the <i>OK</i> button (the literal token for "," must have been created earlier)</li>
</ul>

<p>
Your finished rule should look like the one on the right side of Figure-14 below. 
</p>

<p>
<img src="images/Rule-deductItems.png" alt="The deductItems parser-rule" /><br />
<i>Figure-14. The </i>deductItems<i> parser-rule</i>
</p>

<h2 id="ActionCode">Action Code</h2>

<p>
Action-code is written as anonymous funtion literals in Javascript. 
You can find detailed guidelines at 
<a href="ASTAndActionCode.html#ActionCodeDesign" >Action-Code Design</a>. 
</p>

<h3 id="ActionCodeWeekDays">Action-Code: weekDays</h3>

<p>
The purpose of <i>weekDays</i> is to check the input, and return the integer <i>5</i> if either 
<i>weeks</i> or <i>week</i> is found, and the integer <i>1</i> if <i>days</i> or <i>day</i> 
is found. As described in <a href="#ActionCode">Action Code</a> below, 
action-code functions must handle two cases: a <i>null</i> argument, and a non-null 
(<i>real</i> AST) argument. <i>weekDays</i>' action function only needs to handle the 
non-<i>null</i> argument case. 
(Of all the examples in this article, only the action-code in 
<a href="#WrapperWithActions">Wrapper with Actions</a> below needs to handle 
the <i>null</i>-argument case.)  
</p>

<p>
To understand the logic of the action-code you must 
know the structure of the AST passed in (as the argument <i>a</i>). 
The rule's AST structure is depicted in the text area under 
<i>Parse Tree (AST) Structure</i>. 
<a href="ASTAndActionCode.html#ASTStructure" >AST Structure</a> describes 
AST structuring principles in general. 
</p>

<p>
<img src="images/Action-weekDays.png" alt="The weekDays action-code function" /><br />
<i>Figure-15. The weekDays action-code function</i>
</p>

<p>
The AST structure and action-code of the two subordinate rules used 
by <i>weekDays</i> (<i>weeks</i> and <i>days</i>) is shown in Figure-16 below. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/Action-weeks.png" alt="Action function weeks" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/Action-days.png" alt="Action function days" /></td></tr>
</table>
<i>Figure-16. Action functions of weeks and days rules</i>

<p>
Since <i>weekDays</i>' subordinate rules return the required values (5 and 1), 
its own action-code only needs to pass on the value recieved. Based on the 
above details we know that the AST passed in to <i>weekDays</i> is one of 
these two values: <code>Object[] {0,5}</code>, and <code>Object[] {1, 1}</code> (the 
second member of each array being the value from the subordinate rules). 
So <i>weekDays</i> merely needs to return the second member of the array. 
</p>

<h3 id="ActionCodePercentage">Action-Code: percentage</h3>

<p>
Figure-17 below illustrates the action-code associated with the rule <i>percentage</i>. 
This function uses a non-local reference <code>VLL.grossAmount</code>. 
As described in <a href="ASTAndActionCode.html#ActionCodeDesign" >Action-Code Design</a>, 
the symbol <code>VLL</code> refers to a common global object available to all action-code 
functions, and should be used as a repository for all parser-specific features (methods and 
functions) and state (data). <a href="#WrapperWithActions">Wrapper with Actions</a> below 
illustrates how <code>VLL</code> is equipped with required features before 
testing begins. 
</p>

<p>
<img src="images/Action-percentage.png" alt="A Javascript action-code function" /><br />
<i>Figure-17. A Javascript action-code function</i>
</p>

<p>
The function does not have any setting-up role, so does not have to handle the 
<i>null</i>-argument case. The value of <code>arg</code> it receives is the 
output from the rule <i>doubleNumber</i> (see AST structure). 
It returns the computed percentage value. 
</p>

<h2 id="Testing">Testing</h2>

<p>
Testing is much simpler in <a href="http://vll.java.net/">VisualLangLab</a> than in virtually any other tool. 
<a href="#AdHocTesting">Ad Hoc Testing - A Short Detour</a> showed 
how effective ad hoc manual testing can be in certain situations. 
<a href="http://vll.java.net/">VisualLangLab</a> also supports automated testing, and the following  
sections describe two different approaches for different situations. 
</p>

<h3 id="WrapperWithActions">Wrapper with Actions</h3>

<p>
This approach uses an additional parser-rule to <i>wrap</i> the main 
(or top-level) parser-rule with <i>before</i> and <i>after</i> scripts.
The <i>before</i> script sets up initial conditions before the main 
parser-rule is invoked, and the <i>after</i> script validates the parse-tree 
returned by the main parser-rule. 
Figure-18 below shows details of the wrapper rule <i>PaycheckTester</i> used for testing this parser. 
To display the <i>before</i> and <i>after</i> scripts (actually 
parts of a single action-code function) you must select (click on)
the <i>Reference</i> node that points to the <i>Paycheck</i> parser-rule. 
Parser-rules designed for testing using this technique 
are automatically distinguished with a special icon in the toolbar's dropdown list.
</p>

<p>
<b>If you have not read <a href="ASTAndActionCode.html#ActionCodeDesign" >
Action-Code Design</a> and <a href="ASTAndActionCode.html#ASTStructure" >AST Structure</a>, 
please do so now!</b>
</p>

<p>
<img src="images/Action-PaycheckTester.png" alt="Wrapper rule for automated testing" /><br />
<i>Figure-18. Wrapper rule for automated testing</i>
</p>

<p>
The Javascript function with the before and after scripts is reproduced below for clarity. 
The setup part of the function (<i>null</i>-argument part) performs two functions:
</p>

<ul style="list-style-type: disc;">
  <li>sets up the data-member <code>grossSalary</code>, and creates the 
    method <code>salaryForDays</code> in the global object <code>VLL</code>. 
    (Javascript's dynamic nature allows it to add data and function members 
    to existing objects at run-time)</li>
  <li>deposits a few lines of test input (from 
    <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_let_s_try_it_out_here_is_a_sp" >here</a> in 
    the OFPS version of <i>Programming Scala</i>) into the <i>Parser Test Input</i> area. 
    These lines are processed as input when the main parser-rule (<i>Paycheck</i>) runs</li>
</ul>

<p>
The test part of the code checks the structure 
of the parse-tree returned by the main parser, and prints out an appropriate message. 
</p>

<pre><code>function (arg) {
  if (arg === null) {
//****************************************
//          SETUP actions
//****************************************
  // global variables and functions ...
    VLL = {};
    VLL.grossSalary = 500.0
    VLL.salaryForDays = function (days) {
      return VLL.grossSalary * days;
    }
  // Input text for parser ...
    vllParserTestInput.setText(
      "paycheck for employee \"Buck Trends\"\n" +
      "is salary for 2 weeks minus deductions for {\n" +
      "  federal income tax is 25. percent of gross,\n" +
      "  state income tax is 5. percent of gross,\n" +
      "  insurance premiums are 500. in gross currency,\n" +
      "  retirement fund contributions are 10. percent of gross\n" +
      "}"
    )
  } else {
//****************************************
//          TEST actions
//****************************************
    if (arg.length === 3) {
      var error = ""
      var empl = arg[0];
      if (!empl.equals("Buck Trends")) {
        error += "BAD empl (" + empl + "), ";
      }
      var gross = arg[1].doubleValue();
      if (gross !== 5000) {
        error += "BAD gross (" + gross + "), ";
      }
      var deduct = arg[2].doubleValue();
      if (deduct !== 2500) {
        error += "BAD deduct (" + deduct + "), ";
      }
      if (error === "") {
        return "OK";
      } else {
        return error;
      }
    } else {
      return "BAD AST structure";
    }
  }
}</code></pre>

<p>
To run this test just click the <i>Parse input</i> (<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />) button. You should see the text shown below appear under <i>Parser Test Input</i>, and then "OK" appears in the <i>Parser Log</i> area.
</p>

<pre><code>paycheck for employee "Buck Trends"
is salary for 2 weeks minus deductions for {
  federal income tax is 25. percent of gross,
  state income tax is 5. percent of gross,
  insurance premiums are 500. in gross currency,
  retirement fund contributions are 10. percent of gross
}</code></pre>

<p>
You can also try some error cases. The table below shows some changes (in red) you can make to the input, and the corresponding result messages you should see. To change the input given to the parser (when the <i>Parse input</i> button <img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" /> is clicked) you need to change the input-string in the action code shown above. The input string is the argument to the <code>vllParserTestInput.setText(...)</code> function just after the comment <code>// Input text for parser ...</code>.
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
    <th style="text-align: center; font-weight: bold;">Input</th>
    <th style="text-align: center; font-weight: bold;">Result</th>
  </tr>
  <tr>
    <td style="padding: 2px">... employee &quot;<span style="color: red; font-weight: bold;">D</span>uck Trends&quot; ...</td>
    <td style="padding: 2px">BAD empl, </td>
  </tr>
  <tr>
    <td style="padding: 2px">... salary for 2<span style="color: red; font-weight: bold;">2</span> weeks minus ...</td>
    <td style="padding: 2px">BAD gross, BAD deduct,</td>
  </tr>
  <tr>
    <td style="padding: 2px">... premiums are <span style="color: red; font-weight: bold;">9</span>00. in ...</td>
    <td style="padding: 2px">BAD deduct</td>
  </tr>
</table>

<p>
The variable <i>vllParserTestInput</i> is a reference to the GUI's <code>JTextArea</code> from which the parser under test obtains input (and into which test input is normally entered manually). More information about this can be found under <a href="ASTAndActionCode.html#PredefinedVariables" >
Predefined Variables</a>. 
</p>

<h3 id="JUnitTesting">JUnit Testing</h3>

<p>
It is possible to use JUnit (or any of its successors) to create a test suite for a parser. An description and example of the approach can be found in <a href="TestingParsers.html#UsingJUnit">Using JUnit</a>.
</p>

<h2 id="BuiltinLexicalAnalyzer">Builtin Lexical Analyzer</h2>

<p>
VisualLangLab uses a custom builtin lexer that is significantly more effective than the <code>literal(String)</code> and <code>regex(Regex)</code> methods of Scala's <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a> class. The behavior of this lexer is similar to those in more sophisticated parser development tools, and is described in <a href="RelationshipWithScalaParserCombinators.html#BuiltInLexer">Built-In Lexer</a>. 
</p>

<h3 id="JavaTokenParsers">JavaTokenParsers</h3>

<p>
The builtin lexer can however be <i>too powerful</i> for some applications -- such as this one. For these cases, ending the name of tokens in an underscore (_) is recommended. In handling these tokens, the parser bypasses the builtin lexer and falls back to a <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" >RegexParsers</a>-like capability. 
</p>

<p>
This approach is required (for the <a href="#ImportedElements">three imported tokens</a>) here because the builtin lexer works best when the regex definitions are distinct, and multiple regex tokens do not match the same lexeme. But the regular expressions used in <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html">JavaTokenParsers</a> are such that <code>floatingPointNumber</code> subsumes both <code>decimalNumber</code> and <code>wholeNumber</code>, and <code>decimalNumber</code> itself subsumes <code>wholeNumber</code>. 
</p>

<h2 id="ProsAndCons">Pros and Cons</h2>

<p>
The table below lists the pros and cons of using VisualLangLab compared with 
a hand-written parser based on Scala parser combinators.
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
      <th style="text-align: center; font-weight: bold;">Aspect</th>
      <th style="text-align: center; font-weight: bold;">Pros</th>
      <th style="text-align: center; font-weight: bold;">Cons</th>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="2" style="text-align: center; padding: 2px">Visual</td>
    <td style="padding: 2px">Completely visual. Code never required, except if semantic 
        predicates are used (but they are rare)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">All IDE functions provided - file, edit (tokens, rules, globals), test-run, input-output </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="5" style="text-align: center; padding: 2px">Lexical Analyzer</td>
    <td style="padding: 2px">The builtin lexer works like <a href="http://en.wikipedia.org/wiki/Lexical_analysis" >
        lexical analyzer generators</a>, but does not require any separate steps or tools</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Token definitions may use the full regular-expression language of the JDK's 
        <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" >Pattern</a></td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Unlike 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" >
        RegexParsers</a>, all literal tokens are treated as <i>reserved keywords</i> that have higher priority 
        than regex tokens. The next lexeme provided by the lexer is always the longest possible part of the 
        input that matches any known token</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px"><a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" >
        RegexParsers</a> compatible behavior can also be obtained if required</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Performance is poorer than 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" >
        RegexParsers</a> though no measurements have been made</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="2" style="text-align: center; padding: 2px">AST</td>
    <td style="padding: 2px">Defined and created automatically following a well-defined and documented 
        convention for AST structure. The AST is complete and unambiguous</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The AST is defined using common Java types, so no specialized 
        knowledge is needed. Programs in any JVM language can use the AST. </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="3" style="text-align: center; padding: 2px">Action Code</td>
    <td style="padding: 2px">Completely separated from grammar text. Written as function literals 
        invoked in a well-defined and documented protocol. 
        Action code functions may access their environment via a defined and 
        documented set of predefined <i>global</i> variables.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Never required to be embedded in parser text</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Lexical context of the parser is not available to action code. 
        However, since this restricts the action-code to its own <i>sand-box</i> it can be 
        seen as an an advantage too. </td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">RegexParsers Compatibility</td>
    <td style="padding: 2px">Defines new layer (SimpleLexingRegexParsers) 
        that adds value to RegexParsers's capabilities</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr bgcolor="#dddddd">
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The usual RegexParses interface is exposed to API users</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Not directly compatible, and such code can not be generated</td>
  </tr>

  <tr>
    <td rowspan="4" style="text-align: center; padding: 2px">API</td>
    <td style="padding: 2px">Parser developed in the VisualLangLab IDE may be saved to a file, and 
        subsequently used from a host program via the API</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API usable from <i>any</i> JVM language</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Parser does not have to be compiled or linked into host program.
        The parser can even be modified separately without affecting the host program 
        (provided the AST structure is not changed)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API based on the familiar RegexParsers interface for convenience</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">Testing</td>
    <td style="padding: 2px">Includes comprehensive builtin support for ad hoc testing. 
        No additional tools, code, or skills are required.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Test drivers for black-box testing are easily created and run within 
        the IDE</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Any (or all) rules can be trace-enabled at the click of a button. 
        Even individual grammar-tree nodes can be traced.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
</table>

  </body>
</html>
