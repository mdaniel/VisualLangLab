<html>
  <head>
    <title>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</title>
  </head>

  <body>

<h1>Still under Construction!</h1>
<h2>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</h2>

<p>
<a href="http://vll.java.net/">VisualLangLab</a> is a visual parser-generator 
IDE for developing parsers without code or scripts of any kind. 
Parser-rules are depicted as 
visual <i>grammar-trees</i> with intuitive icons for different nodes types. 
The following figures show how it represents some rules of the payroll-parser 
external DSL described on page 233 of 
<a href="http://programmingscala.com/">Programming Scala</a>. 
The parser code can also be found online at 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar">
A Scala Implementation of the External DSL Grammar</a>. 
<!-- 
The icons and annotations are explained fully in 
<a href="http://vll.java.net/EditingTheGrammarTree.html">Editing the Grammar Tree</a>. 
--> 
</p>

<table border="1" style="border: 1px solid black;"><tbody>
  <tr>
    <th style="text-align: center; font-weight: bold;">amount</th>
    <th style="text-align: center; font-weight: bold;">deductKind</th>
    <th style="text-align: center; font-weight: bold;">deductItems</th>
  </tr>
  <tr>
    <td><img src="images/amount.png" /></td>
    <td><img src="images/deductKind.png" /></td>
    <td><img src="images/deductItems.png" /></td>
  </tr>
</tbody></table>

<p>
The grammar-trees are <i>executable</i>, and can be run at any time at the click of a button. 
No other skills or tools are needed. 
<!-- 
Input for the parser can be entered into the IDE or obtained from user-nominated files. 
-->
This simplifies <a href="#Testing">testing</a>, promotes an iterative-incremental development process, 
and speeds up development manyfold.
<!-- 
Optional <i>actions</i> &mdash; <a href="#ActionCode">snippets of code</a> in Javascript or Scala &mdash; 
can also be embedded in the grammar. 
-->
</p>

<p>
The grammar is saved as a XML file that can be reloaded for further 
<a href="EditingTheGrammarTree.html">editing</a> and 
<a href="#Testing">testing</a>. 
An <a href="UsingTheAPI.html">API</a> enables client programs (Scala or Java) 
to load the XML file and regenerate the parser. 
</p>

<p>
Each grammar-tree <i>is</i> a parser. There is no generated-code or other underlying code representation. 
VisualLangLab uses Scala's parser 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">combinator functions</a> 
to turn each grammar-tree directly into a 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a> 
at run-time as needed. Parser generation is therefore much faster than a code-based approach. 
</p>

<p>
In this tutorial we recreate the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar">
payroll DSL</a> using <a href="http://vll.java.net/">VisualLangLab</a>, 
highlighting its features for parser development and testing.
</p>

<h3>Some Essential Jargon</h3>

<ul style="list-style-type: disc;">
  <li><i>parser</i> (with lower-case inital <i>p</i>) - a program or function for 
    <a href="http://en.wikipedia.org/wiki/Parsing#Parser">parsing and processing input</a> 
     in a certain format. </li>
  <li><i>parser-rule</i> - the 
    <a href="http://en.wikipedia.org/wiki/Formation_rule">simpler units</a> 
    into which a parser is normally broken down. 
    In a Scala combinator-based parser, each <code>def ... : Parser[...] = ...</code> 
    may be considered a parser rule. </li>
  <li><i>grammar-tree</i> - the visual tree used to represent a parser rule 
    in VisualLangLab.</li>
  <li><i>Parser</i> (with upper-case inital <i>P</i>) - a Scala 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">type</a> used to 
    implement <i>parser</i>s as well as <i>parser-rule</i>s</li>
</ul>

<h2>Download and Run VisualLangLab</h2>

<p>
To run VisualLangLab, just download 
<a href="http://java.net/projects/vll/downloads/download/VLLS-All.jar">VLLS-All.jar</a> 
and double-click it in a file-browser. Linux and UNIX users will have to enable execution 
(<i>chmod +x ...</i>) first. 
</p>

<p>
When started, VisualLangLab displays the GUI shown in Figure-2 below. 
The menus and buttons are explained as needed, but a full 
description can also be found at 
<a href="TheGUI.html">The GUI</a>. 
All toolbar buttons have tool-tip texts that explain their use. 
</p>

<p>
<img src="images/GuiFull3.png" /><br />
<i>Figure-?. The VisualLangLab GUI</i>
</p>

<p>
The graphical and text panels are used as described below.
</p>

<ul style="list-style-type: disc;">
  <li>A is used for the grammar-tree as described in 
      <a href="#CreatingParserRules">Creating the Parser-Rules</a> below</li>
  <li>B displays the <a href="#TheParseTree">AST structure</a> 
      of the selected grammar-tree node</li>
  <li>C is where the selected node's <a href="#Actions">action-code</a> 
      (<i>semantic action</i>, or just <i>action</i>) is displayed and edited. 
      If this appears to break the 
      <i>no code, no script</i> promise, rest assured that action-code 
      is always optional</li>
  <li>D and E are used for <a href="#Testing">testing the parser</a> 
      as described below</li>
</ul>

<p>
Another file, <a href="http://java.net/projects/vll/downloads/download/VLLS.jar">VLLS.zip</a>, 
which contains the documentation files, sample grammars, etc. should also be downloaded.
</p>

<h2 id="CreatingParserRules">Creating the Parser-Rules</h2>

<p>
The parser code is organized in top-down fashion, with the high-level 
structures at the top, and the simple structures at the bottom. 
In this tutorial, however, we will start at the bottom, with <i>doubleNumber</i>, 
and work our way up through progressively larger structures till we reach 
the top-level parser <i>payCheck</i>. The following sub-sections 
hand-hold you through the first few (last few actually) parsers.
</p>

<h3>Import Required Tokens</h3>

<p>
Your first step is to import the tokens in <code>JavaTokenParsers</code>, and VisualLangLab 
provides a corresponding <i>token library</i> containing these tokens. 
Select <i>Tokens -> Import tokens</i> from the main menu, or click the <i>Import tokens</i> 
(<img src="images/Import16.gif" align="center"/>) button, and choose the file 
<i>grammars/TL-JavaTokenParsers.vll</i> from the contents of <i>VLLS.zip</i>.
</p>

<p>
Also note that because of differences between Scala's <a href="">RegexParsers</a> 
and VisualLangLab's <a href="">internal lexer</a>, we shall be substituting the 
token <code>decimalNumber</code> wherever <code>floatingPointNumber</code> was used 
in the original code. 
</p>

<h3>def doubleNumber = floatingPointNumber</h3>

<p>
This is a very simple parser-rule, and matches just one unconditional token. 
But as mentioned above, we will modify this parser definition, and implement 
it as the following line instead.
</p>

<pre></code>    def doubleNumber = decimalNumber
</code></pre>

<p>
To create the new rule click the <i>New rule</i> button 
(<img src="images/NewReference.gif" align="center"/>), 
and enter <i>doubleNumber</i> into the dialog box presented as in Figure-? below. 
Clicking the dialog's <i>OK</i> button creates a new rule with just the 
<i>Root</i> node (<img src="images/GrammarIconRoot.gif" align="center"/>)</li>.
</p>

<p>
<img src="images/CreateRule-doubleNumber.png" /><br />
<i>Figure-?. Creating the </i>doubleNumber<i> parser-rule</i>
</p>

<p>
Now right-click the Root node, and select <i>Add -> Token</i> from the popup 
context-menu. Another dialog with all the known token names is presented 
as in Figure-? below. 
Select <i>decimalNumber</i> and click the <i>OK</i> button</li>
</p>

<p>
<img src="images/AddToken-decimalNumber.png" /><br />
<i>Figure-?. Selecting the </i>decimalNumber<i> token</i>
</p>

<p>
Your finished parser should look like the one on the right side of Figure-? above. 
</p>

<h3>def toBe = "is" | "are"</h3>

<p>
This parser-rule uses to custom literal tokens (<i>is</i> and <i>are</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New literal</i> button 
    (the <img src="images/ToolbarButtonNewLiteral.gif" align="center"/> icon), 
    enter <i>IS,is</i> into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-? below)</li>
  <li>repeat the preceding action once more, but enter <i>ARE,are</i> instead</li>
</ul>

<p>
The information entered into the dialog when creating a literal contains the 
literal's <i>name</i>, and its <i>pattern</i> separated by a comma.
You can optionally add spaces around the comma for clarity if required. 
The <i>name</i> is used to refer to the literal in rules (as 
shown below), while the <i>pattern</i> is it's literal definition. 
</p>

<p>
<img src="images/NewLiteral-IsAre.png" /><br />
<i>Figure-?. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
This parser uses a <i>Choice</i> 
(the <img src="images/GrammarIconChoice.gif" align="center"/> icon) as its top-level node. 
A <i>Choice</i> node is a parent of a group of alternatives (any one of which may occur 
in the input). To create the parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>toBe</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) and select 
    <i>Choice</i> from the context menu. A <i>Choice</i> node 
    (<img src="images/GrammarIconChoice.gif" align="center"/>) is added to the root node
    (as in the left and middle parts of Figure-? below)</li>
  <li>right-click the newly created choice node and select <i>Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is popped up. 
    Select <i>IS</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the prceding action, but select the token <i>ARE</i> instead</li>
</ul>

<p>
Your <i>toBe</i> parser should now look like the one on the right side of Figure-? below. 
</p>

<p>
<img src="images/CreateRule-toBe.png" /><br />
<i>Figure-?. The </i>toBe<i> parser</i>
</p>

<p>
The grammar-tree's node icons are designed to be intuitive, but you can find a 
guide to all the icons in 
<a href="EditingTheGrammarTree.html#GrammarTreeIconsAndAnnotations">Grammar Tree Icons and Annotations</a>
</p>

<h3>def amount = toBe ~> doubleNumber <~ "percent" <~ "of" <~ "gross"</h3>

<p>
This parser uses a <i>Sequence</i> 
(the <img src="images/GrammarIconSequence.gif" align="center"/> icon) as its top-level node. 
A <i>Sequence</i> node is a parent of a set of nodes which occur 
in the input in the order specified. To create this parser, perform the following steps.</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>amount</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) and select 
    <i>Sequence</i> from the context menu. A <i>Sequence</i> node 
    (<img src="images/GrammarIconSequence.gif" align="center"/>) is added to the root node</li>
  <li>right-click the newly created sequence node and select <i>Reference</i> from the context menu. 
    A dialog box with a dropdown list containing known parser-rule names is presented. 
    Select <i>toBe</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action, but select the reference <i>doubleNumber</i> instead</li>
  <li>right-click the sequence node and select <i>Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is presented. 
    Select <i>IN</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action two more times, and add the tokens <i>GROSS</i> 
    and <i>CURRENCY</i> to the sequence node</li>
</ul>

<p>
Examining the arrows (<i>~></i> and <i><~</i>) in the <code>def</code>inition, 
we can deduce that only the result of matching <i>doubleNumber</i> is desired to 
be retained. All other tokens are to be dropped from the AST. You can <i>drop</i> 
tokens from the sequence's AST by right-clicking each node's icon and selecting 
<i>drop</i> from the context menu. Remember not to <i>drop</i> the <i>doubleNumber</i> 
token. Your parser should now look like Figure-? below.
</p>

<p>
<img src="images/amount.png" /><br />
<i>Figure-?. The </i>amount<i> parser</i>
</p>

<p>
Observe that the icons of <i>drop</i>ped nodes are overlaid with a black line 
from the lower-left to the upper-right. The 
<a href="EditingTheGrammarTree.html#Annotations">annotation</a> <i>drop</i> is also added 
after the name of th node.
</p>

<h2 id="TestingAShortDetour">Testing - A Short Detour</h2>

<p>
A <a href="#Testing">full section</a> on testing comes later, 
this section demonstrates the simplicity and power of VisualLangLab's 
manual testing facilities. It shows how you can effortlessly 
validate every little addition or change without using or learning 
any other skills or tools. 
</p>

<h3>Validating doubleNumber</h3>

<p>
To manually test <i>doubleNumber</i> proceed as follows (refer Figure-? below).
</p>

<ul style="list-style-type: disc;">
  <li>enter test input under <i>Parser Test Input</i> 
    (green in the figure)</li> 
  <li>click the <i>Parse input</i> button (red)</li> 
  <li>validate the parser's result printed under <i>Parser Log</i> 
    (cyan)</li> 
</ul>

<p>
If you do not see any red text (as in Figure-? below) in the 
<i>Parser Log</i> area, your parser executed without run-time errors. 
But that alone is not enough, you should verify that the result returned 
(for example, <i>25.5</i> in Figure-?) is the value expected. 
</p>

<p>
<img src="images/testing-doubleNumber.png" /><br />
<i>Figure-?. Testing the </i>doubleNumber<i> parser</i>
</p>

<p>
The first two lines of output contain performance 
information that should be ignored (not part of the parser's result). 
Also observe the contents of the text area under the <i>Parse Tree (AST) Structure</i> 
label. AST structuring principles are explained in 
<a href="ASTAndActionCode.html#ASTStructure">AST Structure</a>. 
</p>

<h3>Validating toBe</h3>

<p>
Before you start to enter test data for <i>toBe</i> take a moment to understand 
the structure of its output. All parser rules return an 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (or AST) 
whose structure depends on the arrangement and properties of the grammar-tree's constituent nodes 
as explained in <a href="ASTAndActionCode.html#ASTStructure">AST Structure</a>. 
The text area under <i>Parse Tree (AST) Structure</i> displays the expected AST 
structure of the selected grammar-tree node. Figure-? below tells you that the returned 
result is one of two <code>scala.Pair</code> objects (depending on what was found in the input). 
</p>

<p>
<img src="images/AST-toBe.png" /><br />
<i>Figure-?. The AST of the </i>toBe<i> parser rule</i>
</p>

<p>
Figure-? below shows the result of exercising <i>toBe</i> with three different 
inputs: <i>is</i>, <i>are</i>, and <i>other</i>. 
</p>

<table>
  <tr><td><img src="images/AST-toBe-is.png" /></td></tr>
  <tr><td><img src="images/AST-toBe-are.png" /></td></tr>
  <tr><td><img src="images/AST-toBe-other.png" /></td></tr>
  <tr><td><i>Figure-?. Validating </i>toBe<i> with different inputs</i></td></tr>
</table>

<p>
The performance data in the two lines preceding the parser's result can be 
safely ignored. The first run is typically much slower than subsequent 
runs possibly due to JVM warmup effects. 
</p>

<h2>The Rest of the Parsers</h2>

<p>
All of the remaining parsers, except one that uses a <code>repsep</code> and 
is described fully below, present no new difficulties. We therfore skip the 
details and just show you how they look. If you have understood how the parsers 
described above were created, you should be able to create the remaining ones 
yourself. If you don't have the time, just open the file <i>payroll-parser-comb-v1.vll</i> 
available in the <i>grammars</i> directory of the distribution 
(<a href="http://java.net/projects/vll/downloads/download/VLLS.zip">VLLS.zip</a>). 
As before, we continue northward.
</p>

<table>
<tr><td><img src="images/percentage.png" /></td><td><img src="images/deductAmount.png" /></td><td><img src="images/retirement.png" /></td><td><img src="images/insurance.png" /></td></tr>
</table>

<p>
None of these grammar-rules have anything special or new, so if you are using VisualLangLab 
as you read the article, observe (and possibly try) some of it's features. You should also 
try to validate some of the grammar-trees with your own data. 
</p>

<table>
<tr><td><img src="images/fedState.png" /></td><td><img src="images/tax.png" /></td><td><img src="images/deductKind.png" /></td><td><img src="images/deductItem.png" /></td></tr>
</table>

<p>
Remember that the grammar-trees <i>are</i> the parser. There is no generated-code or 
intermediate-code. VisualLangLab uses Scala's parser 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">combinator functions</a> to turn the grammar-tree directly into a 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a> at run-time without compiling any code. 
That is why the displayed parser-rule <i>runs</i> almost immediately when the 
<i>Parse input</i> button is clicked. 
</p>

<table>
<tr><td><img src="images/weekDays.png" /></td><td><img src="images/duration.png" /></td><td><img src="images/employeeName.png" /></td><td><img src="images/deduct.png" /></td></tr>
</table>

<p>
When you finish developing and testing a parser (or when work must be suspended 
temorarily) the parser can be saved to a file by invoking <i>File -> Save</i> 
from the main menu. The saved grammar file has a <i>.vll</i> extension, 
and contains only an XML representation of all the data entered into the GUI 
(but no other data, code or serialized Scala objects). 
A saved grammar can be opened again later for review, testing, or further modification 
by invoking <i>File -> Open</i> from the main menu. 
</p>

<table>
<tr><td><img src="images/gross.png" /></td><td><img src="images/empl.png" /></td><td><img src="images/paycheck.png" /></td></tr>
</table>

<p>
The remaining parsers ... 
</p>

<h3>def deductItems = repsep(deductItem, ",")</h3>

<p>
This parser uses a <i>RepSep</i> 
(the <img src="images/GrammarIconRepSep.gif" align="center"/> icon) as its top-level node. 
</p>

<p>

<img src="images/deductItems-star.png" /> <img src="images/deductItems.png" /><br />
<i>Figure-?. The </i>deductItems<i> parser</i>
</p>

<p>
As mentioned above, we will modifying this parser definition, and implementing it 
as the following line instead. 
</p>

<h2 id="Actions">Actions</h2>

<p>
approach to automated testing. 
</p>

<h2 id="Testing">Testing</h2>

<p>
Testing is much simpler in VisualLangLab than in almost every other tool. 
<a href="#TestingAShortDetour">Testing - A Short Detour</a> showed 
how effective ad hoc manual testing can be in certain situations. 
VisualLangLab also supports automated testing, and the following  
sections describe two different approaches for different situations. 
</p>

<h3 id="WrapperWithActions">Wrapper with Actions</h3>

<p>
This approach uses an additional parser-rule to <i>wrap</i> the main 
(or top-level) parser-rule with <i>before</i> and <i>after</i> scripts.
The <i>before</i> script sets up initial conditions before the main 
parser-rule is invoked, and the <i>after</i> script validates the parse-tree 
returned by the main parser-rule. 
Figure-? below shows details of the wrapper rule used for testing. 
To display the <i>before</i> and <i>after</i> scripts (actually 
parts of a single action-code function) you must select 
the <i>Reference</i> node that points to the <i>Paycheck</i> parser-rule. 
</p>

<p>
<img src="images/test-wrapper-scala.png" /><br />
<i>Figure-?. Wrapper rule for automated testing</i>
</p>

<p>
The Scala function with the before and after scripts is reproduced below for clarity. 
The setup code deposits a few lines of test input (from 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_let_s_try_it_out_here_is_a_sp">here</a> in 
the OFPS version of <i>Programming Scala</i>) 
into the <i>Parser Test Input</i> area. These lines are processed 
as input when the main parser-rule runs. The test part of the code checks the structure 
of the parse-tree returned by the main parser, and prints out an appropriate message. 
</p>

<pre><code>(arg: Any) => arg match {
//****************************************
//          SETUP actions
//****************************************
  case null => 
    ParserTestInput.text = 
      """|paycheck for employee "Buck Trends"
      |is salary for 2 weeks minus deductions for {
      |federal income tax is 25. percent of gross,
      |state income tax is 5. percent of gross,
      |insurance premiums are 500. in gross currency,
      |retirement fund contributions are 10. percent of gross
      |}""".stripMargin
//****************************************
//          TEST actions
//****************************************
  case Array(empl, gross: Array[_], deduct) =>
    Array(
      if (empl == "\"Buck Trends\"") 
        "OK" 
      else 
        "BAD empl (%s)".format(empl),
      gross match {
        case Array("2", Pair(0, "weeks")) => "OK"
        case _ => "BAD gross (%s)".format(gross.mkString(", "))
      },
      deduct match {
        case List((0,"25."), (0,"5."), (1,"500."), (0,"10.")) => "OK"
        case _ => "BAD deduct (%s)".format(deduct)
      }
    ).mkString(", ")
  case _ => "BAD AST structure"
}</code></pre>

<p>
To understand how this works, let's run it a few times with and 
without changes to the test input. The underlined part is the 
changed text (in the table). To run the test after making changes 
in the action-code click the <i>Save</i> button and wait for 
a pop-up dialog to confirm that the change was accepted, click 
the pop-up's <i>OK</i> button, and then click the <i>Parse input</i> 
(<img src="images/ToolBarButtonParseInput.gif" align="center"/>) button. 
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
    <th style="text-align: center; font-weight: bold;">Input Changes</th>
    <th style="text-align: center; font-weight: bold;">Result</th>
  </tr>
  <tr>
    <td>No changes</td>
    <td>OK, OK, OK</td>
  </tr>
  <tr>
    <td>... employee "<u>D</u>uck Trends" ...</td>
    <td>BAD empl ("Duck Trends"), OK, OK</td>
  </tr>
  <tr>
    <td>... salary for 2<u>2</u> weeks minus ...</td>
    <td>OK, BAD gross (22, (0,weeks)), OK</td>
  </tr>
  <tr>
    <td>... premiums are <u>9</u>00. in ...</td>
    <td>OK, OK, BAD deduct (List((0,25.), (0,5.), (1,900.), (0,10.)))
</td>
  </tr>
</table>

<p>
Near the top of the script, a value called <i>ParserTestInput</i> is 
used. This name is a reference to the GUI's <code>JTextArea</code> 
from which the parser under test obtains input (and into 
which test input is normally entered manually). More information about 
this can be found under <a href="ASTAndActionCode.html#PredefinedVariables">
Predefined Variables</a>. 
</p>

<h3 id="TestingWithJUnit">JUnit + API</h3>

<p>
The ease of testing is another important feature of VisualLangLab. 
</p>

<h2>RegexParsers Compatibility</h2>

<p>
The ease of testing is another important feature of VisualLangLab. 
</p>

<pre><code>
</code></pre>



  </body>
</html>
