<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
  <head>
    <title>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</title>
    <meta name="description" content="Rapid Prototyping for Scala Parser Combinators with VisualLangLab" />
  </head>

  <body>

<h1>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</h1>

<p>
<a href="http://vll.java.net/">VisualLangLab</a> is a visual parser-generator 
IDE for developing parsers without code or scripts of any kind. 
Parser-rules are depicted as visual <i>grammar-trees</i> 
with intuitive icons for different node types. This tutorial highlights 
<a href="http://vll.java.net/">VisualLangLab</a>'s features by recreating the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar" target="_blank">
Payroll External DSL</a> described on page 240 of 
<a href="http://programmingscala.com/" target="_blank">Programming Scala</a>. 
The following figures show how it represents some rules of that parser. 
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
    <th style="text-align: center; font-weight: bold;">amount</th>
    <th style="text-align: center; font-weight: bold;">days</th>
    <th style="text-align: center; font-weight: bold;">deductItems</th>
    <th style="text-align: center; font-weight: bold;">deductKind</th>
  </tr>
  <tr>
    <td style="padding: 0em;"><img src="images/amount.png" alt="The amount grammar" /></td>
    <td style="padding: 0em;"><img src="images/days.png" alt="The days grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductItems.png" alt="The deductItems grammar" /></td>
    <td style="padding: 0em;"><img src="images/deductKind.png" alt="The deductKind grammar" /></td>
  </tr>
</tbody></table>
<i>Figure-1. Some VisualLangLab grammar-trees</i>

<p>
The grammar-trees are <i>executable</i>, and can be run at any time at the click of a button. 
No other skills or tools are needed. 
This simplifies <a href="#Testing">testing</a>, promotes an iterative-incremental development process, 
and speeds up development manyfold.
<a href="http://vll.java.net/">VisualLangLab</a> uses Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html" target="_blank">parser combinator</a> 
functions to turn each grammar-tree <i>directly</i> into a 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank">Parser</a> 
at run-time &mdash; there is no generated-code or other intermediate representation. 
Parser generation (this approach) is much simpler and faster than anything based on code-generation. 
</p>

<p>
The grammar can be saved as a XML file that can be reloaded for further editing and testing. 
An <a href="#APICodeGeneration">API</a> enables user-written programs (in Scala or Java) 
to load the saved XML file and regenerate the parser. 
</p>

<p>
A comparison between this approach and hand-coded Scala parsers can be found in 
<a href="#ProsAndCons">Pros and Cons</a> below.
</p>

<p>
A simpler tutorial is available at  
<a href="http://today.java.net/article/2011/09/14/visuallanglab-grammar-without-tears" target="_blank">
VisualLangLab - Grammar without Tears</a>.
</p>

<h3 id="EssentialJargon">Essential Jargon</h3>

<ul style="list-style-type: disc;">
  <li><i>parser</i> (with lower-case inital <i>p</i>) - in <a href="http://vll.java.net/">VisualLangLab</a> documentation, 
    a parser is an <i>entire</i> program or function for 
    <a href="http://en.wikipedia.org/wiki/Parsing#Parser" target="_blank">parsing and processing input</a> 
     in a certain format. </li>
  <li><i>parser-rule</i> - the 
    <a href="http://en.wikipedia.org/wiki/Formation_rule" target="_blank">simpler units</a> 
    into which a parser is normally broken down. 
    In a Scala combinator-based parser, each <code>def ... : Parser[...] = ...</code> 
    is a parser-rule. Parser-rule and grammar-tree are generally synonymous terms.</li>
  <li><i>grammar-tree</i> - the visual tree used to represent each parser-rule 
    in <a href="http://vll.java.net/">VisualLangLab</a>. Grammar-tree and 
    parser-rule are generally synonymous terms.</li>
  <li><i>Parser</i> (with upper-case inital <i>P</i>) - a 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank">Scala type</a> used to 
    implement <i>parser-rule</i>s as well as the component nodes of parser-rules</li>
</ul>

<h2>Download and Run VisualLangLab</h2>

<p>
To run <a href="http://vll.java.net/">VisualLangLab</a>, just download 
<a href="http://java.net/projects/vll/downloads/download/VLLS-All.jar" target="_blank">VLLS-All.jar</a> 
and double-click it in a file-browser. Linux, Mac OS, and UNIX users will have to enable execution first 
(<i>chmod +x VisualLangLab.jar</i>). 
Another file, <a href="http://java.net/projects/vll/downloads/download/VLLS.jar" target="_blank">VLLS.zip</a>, 
which contains the documentation files, sample grammars, etc. should also be downloaded.
</p>

<p>
When started, <a href="http://vll.java.net/">VisualLangLab</a> displays the GUI shown in Figure-2 below. 
The menus and buttons are explained as needed, but a full 
description can also be found at 
<a href="TheGUI.html" target="_blank">The GUI</a>. 
All toolbar buttons have tool-tip texts that explain their use. 
</p>

<p>
<img src="images/GuiFull3.png" alt="The VisualLangLab GUI" /><br />
<i>Figure-2. The VisualLangLab GUI</i>
</p>

<p>
The display areas of the GUI are used as described below.
</p>

<ul style="list-style-type: disc;">
  <li>A is used for the grammar-tree as described in 
      <a href="#CreatingParserRules">Creating the Parser-Rules</a> below</li>
  <li>B displays the <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST structure</a> 
      of the selected grammar-tree node</li>
  <li>C is where the selected node's <a href="#ActionCode">action-code</a> 
      (<i>semantic action</i>, or just <i>action</i>) is displayed and edited. 
      If this appears to break the 
      <i>no code, no script</i> promise, rest assured that action-code 
      is always optional</li>
  <li>D and E are used for <a href="#Testing">testing the parser</a> 
      as described below</li>
</ul>

<p>
The only prerequisite for running <a href="http://vll.java.net/">VisualLangLab</a> as described above is a 
<a href="http://www.oracle.com/technetwork/java/javase/overview/index-jsp-136246.html" target="_blank">6.0+ JRE</a>. 
But if you want to use the <a href="http://vll.java.net/">VisualLangLab</a> 
<a href="#APICodeGeneration">API</a> to develop standalone applications, a 
<a href="http://www.scala-lang.org/downloads" target="_blank">2.9.0+ Scala</a> installation is required. 
</p>

<h2 id="CreatingParserRules">Creating the Parser-Rules</h2>

<p>
In the book, the parser-rules are organized in top-down fashion. 
But here, we start at the bottom with <i>doubleNumber</i>, and work our way up, 
creating some of the parser-rules so as to demonstrate most of 
<a href="http://vll.java.net/">VisualLangLab</a>'s features. The complete parser is also 
included as the file <i>payroll-parser-comb.vll</i> in the <i>grammars</i> directory of the zip distribution. 
</p>

<h3>Import Required Tokens</h3>

<p>
The book's code starts by importing 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">JavaTokenParsers</a> 
and you can obtain the same effect in <a href="http://vll.java.net/">VisualLangLab</a> 
by importing the corresponding <i>token library</i>. 
Select <i>Tokens -> Import tokens</i> from the main menu, or click the <i>Import tokens</i> 
(<img src="images/Import16.gif" align="center" alt="The import-tokens GUI" />) button, and choose the file 
<i>TL-JavaTokenParsers.vll</i> from the the <i>grammars</i> directory of the zip distribution. 
This token-library contains <i>regex</i> tokens with the same names and functionality. 
However, for reasons explained in <a href="#JavaTokenParsers">JavaTokenParsers</a> 
below, all the names have an underscore (_) suffix. 
</p>

<h3 id="DefDoubleNumber">def doubleNumber = floatingPointNumber ...</h3>

<p>
This is a very simple parser-rule, and just matches one token unconditionally. 
To create the new rule click the <i>New rule</i> button 
(<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
and enter <i>doubleNumber</i> into the dialog box presented as in Figure-3 below. 
Clicking the dialog's <i>OK</i> button creates a new rule with just a 
<i>Root</i> node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />).
</p>

<p>
<img src="images/CreateRule-doubleNumber.png" alt="Creating the doubleNumber parser-rule" /><br />
<i>Figure-3. Creating the </i>doubleNumber<i> parser-rule</i>
</p>

<p>
Now right-click the Root node, and select <i>Add -> Token</i> from the popup 
context-menu. Another dialog with the names of available tokens is presented 
as shown on the left side of Figure-4 below. 
Select <i>decimalNumber_</i> and click the <i>OK</i> button. Your almost-complete 
parser-rule should look like the right side of Figure-4 below. 
</p>

<p>
<img src="images/AddToken-decimalNumber.png" alt="Selecting the decimalNumber token" /><br />
<i>Figure-4. Selecting the </i>decimalNumber<i> token</i>
</p>

<p>
Finally, we need to add some action-code. Select (click) the <i>decimalNumber</i> token 
(<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), and paste the Scala code 
given below into the text area under <i>Action Code</i> as in Figure-5 
below. Click the <i>Save</i> button. Observe that this adds the <i>action</i> annotation 
to the <i>decimalNumber</i> token. 
</p>

<pre><code>(a: Any) => a match {
  case null =>
  case d: String => d.toDouble
}</code></pre>

<p>
Action-code functions are explained further in <a href="#ActionCode">Action Code</a> below. 
</p>

<p>
<img src="images/Action-doubleNumber.png" alt="Adding action-code to the doubleNumber rule" /><br />
<i>Figure-5. Adding action-code to the </i>doubleNumber<i> rule</i>
</p>

<h3>def toBe = "is" | "are"</h3>

<p>
This parser-rule uses two custom literal tokens (<i>is</i> and <i>are</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New literal</i> button 
    (the <img src="images/ToolBarButtonNewLiteral.gif" align="center" alt="The New-literal button" /> icon), 
    enter <i>IS,is</i> into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-6 below)</li>
  <li>repeat the preceding action once more, but enter <i>ARE,are</i> instead</li>
</ul>

<p>
The information entered into the dialog when creating a literal contains the 
literal's <i>name</i>, and its <i>pattern</i> separated by a comma.
You can optionally add spaces around the comma for clarity if required. 
The <i>name</i> is used to refer to the literal in rules (as 
seen in <a href="#Figure7">Figure-7</a> below), while the <i>pattern</i> is it's literal definition. 
</p>

<p>
<img src="images/NewLiteral-IsAre.png" alt="Creating the is and are tokens" /><br />
<i>Figure-6. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
This parser-rule uses a <i>Choice</i> 
(the <img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" /> icon) as its top-level node. 
A <i>Choice</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of the 
<i>|</i> combinator. But unlike <i>|</i> it accepts an arbitrary number (&gt;= 2) of 
child nodes, and returns an AST that remembers which child node matched the input 
(see <a href="#ScalaActionCodeWeekDays">example below</a>). 
To create the parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-reference button" />), 
    enter <i>toBe</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) and select 
    <i>Add -> Choice</i> from the context menu. A <i>Choice</i> node 
    (<img src="images/GrammarIconChoice.gif" align="center" alt="The Choice icon" />) is added to the root node
    (as in the left and middle parts of Figure-7 below)</li>
  <li>right-click the newly created choice node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is popped up. 
    Select <i>IS</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the prceding action, but select the token <i>ARE</i> instead</li>
</ul>

<p>
Your <i>toBe</i> parser-rule should now look like the one on the right side of Figure-7 below. 
</p>

<p id="Figure7">
<img src="images/CreateRule-toBe.png" alt="The toBe parser" /><br />
<i>Figure-7. The </i>toBe<i> parser</i>
</p>

<p>
The grammar-tree's node icons are designed to be intuitive, but you can find a 
guide to all the icons in 
<a href="EditingTheGrammarTree.html#GrammarTreeIconsAndAnnotations" target="_blank">
Grammar Tree Icons and Annotations</a>
</p>

<h3>def percentage = toBe ~> doubleNumber <~ "percent" <~ "of" <~ "gross" ...</h3>

<p>
This parser-rule uses a <i>Sequence</i> 
(the <img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" /> icon) as its top-level node. 
A <i>Sequence</i> is <a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of 
the <i>~</i>, <i>&lt;~</i>, and <i>~&gt;</i> combinators. But unlike the <i>~</i> family, 
it accepts an arbitrary number (&gt;= 2) of child nodes, 
and the AST returned is just a <code>scala.Array</code> which is much simpler to handle 
than a nested instance of <code>case class ~</code>. 
To create this parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>percentage</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root icon" />) and select 
    <i>Add -> Sequence</i> from the context menu. A <i>Sequence</i> node 
    (<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />) is added to the root node</li>
  <li>right-click the newly created sequence node and select <i>Add -> Reference</i> from the context menu. 
    A dialog box with a dropdown list containing known parser-rule names is presented. 
    Select <i>toBe</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action once more, selecting the reference <i>doubleNumber</i> instead</li>
  <li>right-click the sequence node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is presented. 
    Select <i>PERCENT</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action two more times, and add the tokens <i>OF</i> 
    and <i>GROSS</i> to the sequence node</li>
</ul>

<p>
Examining the arrows (<i>~></i> and <i><~</i>) in the <code>def</code>inition, 
we can deduce that only the result of matching <i>doubleNumber</i> is desired to 
be retained. All other tokens are to be dropped from the AST. You can <i>drop</i> 
tokens from the sequence's AST by right-clicking each node's icon and selecting 
<i>drop</i> from the context menu (as shown on the left side of the figure). 
Remember not to <i>drop</i> the <i>doubleNumber</i> token. 
Your finished parser-rule should now look like the left side of Figure-8 below.
</p>

<p>
<img src="images/Rule-percentage.png" alt="The percentage parser-rule" /><br />
<i>Figure-8. The </i>percentage<i> parser-rule</i>
</p>

<p>
Observe that the icons of <i>drop</i>ped nodes are overlaid with a black line 
from the lower-left to the upper-right. The 
<a href="EditingTheGrammarTree.html#Annotations" target="_blank">annotation</a> <i>drop</i> is also added 
after the name of the node.
</p>

<p>
Finally, add the action-code: select (click) the <i>Sequence</i> icon 
(<img src="images/GrammarIconSequence.gif" align="center" alt="The Sequence icon" />), and paste the Javascript code 
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>function (arg) {
  if (arg !== null) {
    return VLL.grossAmount * (arg / 100);
  }
}</code></pre>

<p>
Though different from the original text, this action function is actually functionally 
equivalent, as explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one in Figure-8 above. 
</p>

<h3>def days = "days?".r ...</h3>

<p>
This parser-rule uses a custom regex token (<i>days?</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New regex</i> button 
    (the <img src="images/ToolBarButtonNewRegex.gif" align="center" alt="The New-regex button" /> icon), 
    enter <i>DAYS,days?</i> into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-9 below). Here <i>days?</i> is a regular-expression 
    <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank">Pattern</a></li>
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>days</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center alt="The Root node" "/>) 
    and select <i>Add -> Token</i> from the context menu. 
    Select <i>DAYS</i> from the dropdown list, and click the <i>OK</i> button</li>
</ul>

<p>
<img src="images/NewRegex-days.png" alt="Creating the is and are tokens" /><br />
<i>Figure-9. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
Finally, add the action-code by selecting he <i>DAYS</i> icon 
(<img src="images/GrammarIconRegex.gif" align="center" alt="The Regex icon" />), and pasting the Scala code  
given below into the text area under <i>Action Code</i>. Then click the <i>Save</i> button. 
</p>

<pre><code>(a: Any) => a match {
  case null =>
  case _ => 1
}</code></pre>

<p>
Action-code function design and use is explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like the one on the right side of Figure-9 above. 
</p>

<h2 id="AdHocTesting">Ad Hoc Testing - A Short Detour</h2>

<p>
A <a href="#Testing">full section</a> on testing comes later, 
this section demonstrates the simplicity and power of <a href="http://vll.java.net/">VisualLangLab</a>'s 
manual testing facilities. It shows how you can effortlessly 
validate every little addition or change without using or learning 
any other skills or tools. 
</p>

<h3>Validating doubleNumber</h3>

<p>
To manually test <i>doubleNumber</i> proceed as follows. Use the toolbar's combo box 
to select <i>doubleNumber</i> as in Figure-10 below.
</p>

<ul style="list-style-type: disc;">
  <li>enter test input under <i>Parser Test Input</i> 
    (red rectangle at bottom left)</li> 
  <li>click the <i>Parse input</i> button (<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />)</li> 
  <li>validate the parser's result printed under <i>Parser Log</i> 
    (wide red rectangle at bottom right)</li> 
</ul>

<p>
If you do not see any red text (as in <a href="#Figure12">Figure-12</a> below) in the 
<i>Parser Log</i> area, your parser executed without errors. 
But that alone is not enough, you should verify that the result returned 
(the <i>25</i> in Figure-10, for example) is the value expected. 
</p>

<p>
<img src="images/testing-doubleNumber.png" alt="Testing the doubleNumber parser" /><br />
<i>Figure-10. Testing the </i>doubleNumber<i> parser</i>
</p>

<p>
The parser's <i>result</i> or AST is on the third line (after the <i>result follows:</i>). 
The previous two lines of output contain performance 
information that should be ignored. 
This test passes as <i>25</i> (last line under <i>Parser Log</i>) is the expected 
result. 
</p>

<h3>Validating toBe</h3>

<p>
Before you start to enter test data for <i>toBe</i> take a moment to understand 
the structure of its output. All parser-rules return an 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">abstract syntax tree</a> (or AST) 
whose structure depends on the arrangement and properties of the grammar-tree's constituent nodes 
as explained in <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a>. 
The text area under <i>Parse Tree (AST) Structure</i> displays the expected AST 
structure of the selected grammar-tree node. Figure-11 below tells you that the returned 
result is one of two <code>scala.Pair</code> objects (depending on what was found in the input). 
</p>

<p>
<img src="images/AST-toBe.png" alt="The AST of the toBe parser-rule" /><br />
<i>Figure-11. The AST of the </i>toBe<i> parser-rule</i>
</p>

<p id="Figure12">
Figure-12 below shows the result of exercising <i>toBe</i> with three different 
inputs: <i>is</i>, <i>are</i>, and <i>other</i>. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-is.png" alt="The AST of toBe with is" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-are.png" alt="The AST of toBe with are" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/AST-toBe-other.png" alt="The AST of toBe with other" /></td></tr>
  <tr><td style="padding: 2px"><i>Figure-12. Validating </i>toBe<i> with different inputs</i></td></tr>
</table>

<p>
This set of tests too pass as all three test cases produce the expected result. 
</p>

<h2>The Remaining Parser-Rules</h2>

<p>
The remaining parser-rules, except one that uses a <code>repsep</code> and 
is described fully below, present no new difficulties and 
we leave them as an exercise for the reader. 
You can verify your creation by comparing it with the saved-grammar file 
<i>payroll-parser-comb.vll</i> in the <i>grammars</i> directory of the zip distribution. 
</p>

<h3>def deductItems = repsep(deductItem, ",")</h3>

<p>
This parser-rule uses a <i>RepSep</i> 
(the <img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" /> icon) as its top-level node. 
To create this rule proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center" alt="The New-rule button" />), 
    enter <i>deductItems</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center" alt="The Root node" />) and select 
    <i>Add -> RepSep</i> from the context menu (as on the left side of Figure-13 below). 
    A <i>RepSep</i> node 
    (<img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep icon" />) is added to the root node</li>
  <li>right-click the newly created RepSep node and select <i>Reference</i> from the context menu. 
    A dialog with known parser-rule names is presented. 
    Select <i>deductItem</i> from the dropdown, and click the <i>OK</i> button</li>
  <li>right-click the RepSep node again and select <i>Add -> Token</i> from the context menu. 
    Select <i>COMMA</i> from the dropdown, and click the <i>OK</i> button</li>
</ul>

<p>
Your finished rule should look like the one on the right side of Figure-13 below. 
</p>

<p>
<img src="images/Rule-deductItems.png" alt="The deductItems parser-rule" /><br />
<i>Figure-13. The </i>deductItems<i> parser-rule</i>
</p>

<p>
If you did create <i>deductItems</i> you will notice a little red 'x' at 
the top-right corner of the rule's root node. 
This is the error flag, and making the mouse hover over the root-node 
displays the nature of the problem (in the tool-tip text). 
Both these features can be seen on the right side of Figure-13 above. 
</p>

<p>
The problem is that <i>deductItems</i> can return successfully without 
matching any input. But <a href="http://vll.java.net/">VisualLangLab</a> forbids the use of such parser-rules 
as it is possible to create very obscure and difficult-to-diagnose errors 
with them. The solution, in this case, is quite simple &mdash; implant 
the contents of  <i>deductItems</i> directly into it's client rule 
(<i>deduct</i>). Figure-14 below shows the required modification of <i>deduct</i>. 
</p>

<p>
<img src="images/Rule-deduct-modified.png" alt="Modifying the deduct rule" /><br />
<i>Figure-14. Modifying the </i>deduct<i> rule</i>
</p>

<p>
In terms of the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl" target="_blank">
original parser combinator code</a>, we made the following change. 
</p>

<pre><code>def deduct = "minus" ~> "deductions" ~> "for" ~> 
    "{" ~> <del>deductItems</del> <u>repsep(deductItem, "," )</u>  <~ "}"
<del>def deductItems = repsep(deductItem, "," )</del></code></pre>

<p>
Finally, select the <i>RepSep</i> node 
(<img src="images/GrammarIconRepSep.gif" align="center" alt="The RepSep node" />), and paste the Scala code 
given below into the text area under <i>Action Code</i> as in Figure-15 below. 
Click the <i>Save</i> button. 
</p>

<pre><code>(a:Any) => a match {
  case null =>
  case ld: List[Double] => ld.foldLeft(0.0){_ + _}
}</code></pre>

<p>
The action-code function is explained further in <a href="#ActionCode">Action Code</a> below. 
Your finished parser-rule should look like Figure-15 below. 
</p>

<p>
<img src="images/Action-deductItems.png" alt="Adding action-code to the deductItems rule" /><br />
<i>Figure-15. Adding action-code to the </i>deductItems<i> rule</i>
</p>

<p>
Note the little <i>*</i> next to the RepSep icon. The <i>*</i> indicates the <i>multiplicity</i> 
of the node &mdash; zero or more. A RepSep node can have two multiplicities: <i>*</i> (zero 
or more) and <i>+</i> (one or more). A RepSep node is 
<a href="http://vll.java.net/">VisualLangLab</a>'s equivalent of the <i>repsep</i> and 
<i>rep1sep</i> combinators. The RepSep node's multiplicity determines which one it emulates. 
</p>

<p>
Grammar-tree node multiplicities and other details are explained in 
<a href="EditingTheGrammarTree.html#Annotations" target="_blank">Annotations</a>.
</p>

<h2 id="ActionCode">Action Code</h2>

<p>
Action-code is written as anonymous funtion literals in Scala or Javascript. 
Both languages can be mixed freely in a parser, but each function must be written in 
one of the forms shown below. Semantically equivalent abbreviated forms in Scala 
(using _ to imply the argument) are not allowed. 
The name of the argument and use of whitespace characters may, however, vary.
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
      <th style="text-align: center; font-weight: bold;">Scala</th>
      <th style="text-align: center; font-weight: bold;">Javascript</th></tr>
  <tr>
      <td style="padding: 5px"><code>(arg: Any) => { ... }</code></td>
      <td style="padding: 5px"><code>function (arg) { ... }</code></td></tr>
</table>

<p>
The choice of language for the examples in this article is based on one criterion: 
presence of references to external objects. 
completely self-contained functions with no external references are coded in Scala, 
while those with external data or function references are coded in Javascript. 
You can find detailed guidelines at 
<a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">Action-Code Design</a>. 
</p>

<p>
In general, action code from the original 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl" target="_blank">
parser code</a> can not be used verbatim as <a href="http://vll.java.net/">VisualLangLab</a>'s 
<a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST structure</a> differs in many cases.  
A few examples of action-code functions in Scala and Javascript are shown below. 
Observe that grammar-tree nodes with associated action-code have the 
<i>action</i> attribute marked next to the node's icon. To see the 
action-code you have to select (click) the specific node. 
</p>

<h3 id="ExternalResources">External Resources</h3>

<p>
Because action-code functions execute in a closed environment, 
it is difficult to load and use custom classes (like 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_here_is_the_simple_paycheck_" target="_blank">
Paycheck</a>, 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_the_money_type_handles_arith" target="_blank">
Money</a>, etc.). This is where Javascript's dynamic features help. 
As shown in <a href="#WrapperWithActions">Wrapper with Actions</a> 
below, those features can be used to create Javascript objects and methods 
to substitute the missing native (Scala or Java) resources. 
This approach is frequently adequate in a limited context such as testing. 
More exacting situations that must load external classes must be handled via 
the <a href="#APICodeGeneration">API</a>. 
</p>

<h3 id="ScalaActionCodeWeekDays">Scala Action-Code: weekDays</h3>

<p>
The purpose of <i>weekDays</i> is to check the input, and return the integer <i>5</i> if either 
<i>weeks</i> or <i>week</i> is found, and the integer <i>1</i> if <i>days</i> or <i>day</i> 
is found. As described in <a href="#ActionCode">Action Code</a> below, 
action-code functions must handle two cases: a <i>null</i> argument, and a non-null 
(<i>real</i> AST) argument. <i>weekDays</i>' action function only needs to handle the 
non-<i>null</i> argument case. 
(Of all the examples in this article, only the action-code in 
<a href="#WrapperWithActions">Wrapper with Actions</a> below needs to handle 
the <i>null</i>-argument case.)  
</p>

<p>
To understand the logic of the action-code you must 
know the structure of the AST passed in (as the argument <i>a</i>). 
The rule's AST structure is depicted in the text area under 
<i>Parse Tree (AST) Structure</i>. 
<a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a> describes 
AST structuring principles in general. 
</p>

<p>
<img src="images/Action-weekDays.png" alt="A Scala action-code function" /><br />
<i>Figure-16. A Scala action-code function</i>
</p>

<p>
The AST structure and action-code of the two subordinate rules used 
by <i>weekDays</i> (<i>weeks</i> and <i>days</i>) is shown in Figure-17 below. 
</p>

<table>
  <tr><td style="padding: 2px"><img src="images/Action-weeks.png" alt="Action function weeks" /></td></tr>
  <tr><td style="padding: 2px"><img src="images/Action-days.png" alt="Action function days" /></td></tr>
</table>
<i>Figure-17. Action functions of weeks and days rules</i>

<p>
Since <i>weekDays</i>' subordinate rules return the required values (5 and 1), 
its own action-code only needs to pass on the value recieved. Based on the 
above details we know that the AST passed in to <i>weekDays</i> is one of 
these two values: <code>Pair(0,5)</code>, and <code>Pair(0,1)</code> (the 
second member of each <code>Pair</code> being the value from the subordinate rules). 
So <i>weekDays</i> merely needs to return the second member of the <code>Pair</code>. 
</p>

<h3 id="JavascriptActionCodePercentage">Javascript Action-Code: percentage</h3>

<p>
Figure-18 below illustrates the action-code associated with the rule <i>percentage</i>. 
This function uses a non-local reference <code>VLL.grossAmount</code>. 
As described in <a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">Action-Code Design</a>, 
the symbol <code>VLL</code> refers to a common global object available to all action-code 
functions, and should be used as a repository for all parser-specific features (methods and 
functions) and state (data). <a href="#WrapperWithActions">Wrapper with Actions</a> below 
illustrates how <code>VLL</code> is equipped with required features before 
testing begins. 
</p>

<p>
<img src="images/Action-percentage.png" alt="A Javascript action-code function" /><br />
<i>Figure-18. A Javascript action-code function</i>
</p>

<p>
The function does not have any setting-up role, so does not have to handle the 
<i>null</i>-argument case. The value of <code>arg</code> it receives is the 
output from the rule <i>doubleNumber</i> (see AST structure) which is a 
<code>scala.Double</code>. It returns the computed percentage value. 
</p>

<h2 id="Testing">Testing</h2>

<p>
Testing is much simpler in <a href="http://vll.java.net/">VisualLangLab</a> than in virtually any other tool. 
<a href="#AdHocTesting">Ad Hoc Testing - A Short Detour</a> showed 
how effective ad hoc manual testing can be in certain situations. 
<a href="http://vll.java.net/">VisualLangLab</a> also supports automated testing, and the following  
sections describe two different approaches for different situations. 
</p>

<h3 id="WrapperWithActions">Wrapper with Actions</h3>

<p>
This approach uses an additional parser-rule to <i>wrap</i> the main 
(or top-level) parser-rule with <i>before</i> and <i>after</i> scripts.
The <i>before</i> script sets up initial conditions before the main 
parser-rule is invoked, and the <i>after</i> script validates the parse-tree 
returned by the main parser-rule. 
Figure-19 below shows details of the wrapper rule <i>PaycheckTester</i> used for testing this parser. 
To display the <i>before</i> and <i>after</i> scripts (actually 
parts of a single action-code function) you must select (click on)
the <i>Reference</i> node that points to the <i>Paycheck</i> parser-rule. 
</p>

<p>
<b>If you have not read <a href="ASTAndActionCode.html#ActionCodeDesign" target="_blank">
Action-Code Design</a> and <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a>, 
please do so now!</b>
</p>

<p>
<img src="images/Action-PaycheckTester.png" alt="Wrapper rule for automated testing" /><br />
<i>Figure-19. Wrapper rule for automated testing</i>
</p>

<p>
The Javascript function with the before and after scripts is reproduced below for clarity. 
The setup part of the function (<i>null</i>-argument part) performs two functions:
</p>

<ul style="list-style-type: disc;">
  <li>sets up the data-member <code>grossSalary</code>, and creates the 
    method <code>salaryForDays</code> in the global object <code>VLL</code>. 
    (Javascript's dynamic nature allows it to add data and function members 
    to existing objects at run-time)</li>
  <li>deposits a few lines of test input (from 
    <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_let_s_try_it_out_here_is_a_sp" target="_blank">here</a> in 
    the OFPS version of <i>Programming Scala</i>) into the <i>Parser Test Input</i> area. 
    These lines are processed as input when the main parser-rule (<i>Paycheck</i>) runs</li>
</ul>

<p>
The test part of the code checks the structure 
of the parse-tree returned by the main parser, and prints out an appropriate message. 
</p>

<pre><code>function (arg) {
  if (arg === null) {
//****************************************
//          SETUP actions
//****************************************
  // global variables and functions ...
    VLL.grossSalary = 500.0
    VLL.salaryForDays = function (days) {
      return VLL.grossSalary * days;
    }
  // Input text for parser ...
    ParserTestInput.setText(
      "paycheck for employee \"Buck Trends\"\n" +
      "is salary for 2 weeks minus deductions for {\n" +
      "  federal income tax is 25. percent of gross,\n" +
      "  state income tax is 5. percent of gross,\n" +
      "  insurance premiums are 500. in gross currency,\n" +
      "  retirement fund contributions are 10. percent of gross\n" +
      "}"
    )
  } else {
//****************************************
//          TEST actions
//****************************************
    if (arg.length === 3) {
      var error = ""
      var empl = arg[0];
      if (empl !== "Buck Trends") {
        error += "BAD empl, "
      }
      var gross = arg[1];
      if (gross !== 5000) {
        error += "BAD gross, "
      }
      var deduct = arg[2];
      if (deduct !== 2500) {
        error += "BAD deduct"
      }
      if (error === "") {
        return "OK";
      } else {
        return error;
      }
    } else {
      return "BAD AST structure";
    }
  }
}</code></pre>

<p>
To understand how this works, let's run it a few times with and 
without changes to the test input as in the table below. The red text is the 
changed part (in the table). To run the test after making changes 
in the action-code click the <i>Save</i> button and wait for 
a pop-up dialog to confirm that the change was accepted, click 
the pop-up's <i>OK</i> button, and then click the <i>Parse input</i> 
(<img src="images/ToolBarButtonParseInput.gif" align="center" alt="The Parse-input button" />) button. 
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
    <th colspan="2" style="text-align: center; font-weight: bold;">Sample Inputs for Rule Paycheck</th>
  </tr>
  <tr>
    <th style="text-align: center; font-weight: bold;">Input</th>
    <th style="text-align: center; font-weight: bold;">Result</th>
  </tr>
  <tr>
    <td style="padding: 2px">No changes</td>
    <td style="padding: 2px">OK</td>
  </tr>
  <tr>
    <td style="padding: 2px">... employee &quot;<span style="color: red; font-weight: bold;">D</span>uck Trends&quot; ...</td>
    <td style="padding: 2px">BAD empl, </td>
  </tr>
  <tr>
    <td style="padding: 2px">... salary for 2<span style="color: red; font-weight: bold;">2</span> weeks minus ...</td>
    <td style="padding: 2px">BAD gross, BAD deduct,</td>
  </tr>
  <tr>
    <td style="padding: 2px">... premiums are <span style="color: red; font-weight: bold;">9</span>00. in ...</td>
    <td style="padding: 2px">BAD deduct</td>
  </tr>
</table>

<p>
Near the top of the script, a value called <i>ParserTestInput</i> is 
used. This name is a reference to the GUI's <code>JTextArea</code> 
from which the parser under test obtains input (and into 
which test input is normally entered manually). More information about 
this can be found under <a href="ASTAndActionCode.html#PredefinedVariables" target="_blank">
Predefined Variables</a>. 
</p>

<h3 id="TestingWithJUnit">JUnit + API</h3>

<p>
The example code below illustrates a JUnit test case that exercises two of the 
parser-rules (<i>weekDays</i> and <i>Paycheck</i>) in the parser we created earlier. 
The code uses the <a href="#APICodeGeneration">VisualLangLab API</a> (red lines), 
as well as the <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
RegexParsers</a> interface (blue lines). The code uses the API to regenerate the parser 
from a saved grammar file. 
The grammar file used (<i>payroll-parser-comb-noaction.vll</i>) is a modified version of 
the parser described above that has all the action-code removed. Using a grammar without any 
actions gives better insight into the overall process, and results in more precise 
tests.
</p>

<p>
The test-case includes one test for each of the two 
parser-rules mentioned above.The test for <i>weekDays</i> has six separate checks. The first four checks verify 
that the rule accepts <i>week</i>, <i>weeks</i>, <i>day</i>, and <i>days</i>, and returns 0, 
0, 1, and 1 respectively. The last two checks verify that it does not accept 
<i>daily</i> and <i>weekly</i>. 
The test for <i>Paychecks</i> has two checks &mdash; one without deductions and another 
with deductions. The data for these checks is from 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_the_following_specification_w" target="_blank">
the code on pages 243 and 244</a> of 
<a href="http://programmingscala.com/" target="_blank">the book</a>. 
</p>

<pre><code>import java.io.File
import org.junit.Test
import org.junit.Assert._
import org.junit.runner.JUnitCore
<span style="color:red; font-weight: bold;">import vll.core.VllParsers</span>
import scala.collection.JavaConversions._

class PayrollDSLTest {
  val withDeductions = """paycheck for employee "Buck Trends"
          |is salary for 2 weeks minus deductions for {
          |  federal income tax is 25. percent of gross,
          |  state income tax is 5. percent of gross,
          |  insurance premiums are 900. in gross currency,
          |  retirement fund contributions are 10. percent of gross
          |}""".stripMargin
  val noDeductions = """paycheck for employee "Buck Trends"
          |is salary for 2 weeks minus deductions for {
          |}""".stripMargin
  
  val vllParsers = <span style="color:red; font-weight: bold;">VllParsers.fromFile</span>(new File("payroll-parser-comb-noaction.vll"))
  
  @Test def weekDays() {
    val parser = <span style="color:red; font-weight: bold;">vllParsers.getParserFor</span>("weekDays")
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "week") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Pair(0, "week"), _) => true; case _ => false})
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "weeks") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Pair(0, "weeks"), _) => true; case _ => false})
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "day") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Pair(1, "day"), _) => true; case _ => false})
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "days") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Pair(1, "days"), _) => true; case _ => false})
    assertFalse(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "daily") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(_, _) => true; case _ => false})
    assertFalse(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, "weekly") match 
        {case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(_, _) => true; case _ => false})
  }
  
  @Test def paycheck() {
    val parser = <span style="color:red; font-weight: bold;">vllParsers.getParserFor</span>("Paycheck")
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, noDeductions) match {
        case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Array("\"Buck Trends\"", 
            Array("2", Pair(0, "weeks")), Nil), _) => true
        case _ => false})
    assertTrue(<span style="color:blue; font-weight: bold;">vllParsers.parseAll</span>(parser, withDeductions) match {
        case <span style="color:blue; font-weight: bold;">vllParsers.Success</span>(Array("\"Buck Trends\"", 
            Array("2", Pair(0, "weeks")), List(Pair(0, "25."), Pair(0, "5."), 
            Pair(1, "900."), Pair(0, "10."))), _) => true
        case _ => false})
  }
}</code></pre>

<p>
The tests use Scala's pattern-matching capability to verify the structure of the parse-tree 
returned by the parser. The redability of the AST verifying code is enhanced by the fact that 
the convention used for <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST Structure</a> 
uses standard classes from the Scala API. Either <i>VLLS.jar</i> or <i>VLLS-All.jar</i> 
must be on the classpath when compiling and running this code. 
</p>

<h2 id="APICodeGeneration">The API, Code-Generation, etc.</h2>

<p>
One of the first questions that most people have is <i>how do I generate 
the parser code</i>? The short answer is <i>you can't</i>; a somewhat 
longer one is <i>you don't have to</i>. Here's why:
</p>

<p>
<a href="http://vll.java.net/">VisualLangLab</a> never generates any parser code &mdash; not even for its own 
internal use. It uses the capabilities of 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank"> 
Parser</a> and 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank"> 
RegexParsers</a> to produce 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank"> 
Parser</a> instances <i>directly</i> from grammar-trees at run-time 
without generating or compiling any code. The Parsers produced have all the features 
and properties assigned to the grammar-trees by <a href="http://vll.java.net/">VisualLangLab</a>'s grammar-tree editor. 
The same Parser-generation procedure is available to host programs through the 
<a href="UsingTheAPI.html">VisualLangLab API</a>. 
To use a Parser from a Scala program, proceed as follows.
</p>

<ol style="list-style-type:decimal;">
  <li>In the <a href="http://vll.java.net/">VisualLangLab</a> GUI, save the grammar to a file by invoking <i>File -> Save</i> or 
    <i>File -> SaveAs</i></li>
  <li>In a the client program, use the API's <code>VllParsers.fromFile(java.io.File)</code> function 
    to create an instance of <code>vll.core.VllParsers</code>. This class extends the Scala API's 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">RegexParsers</a>, 
    but has some additional <a href="http://vll.java.net/">VisualLangLab</a>-specific features illustrated below</li>
  <li>Use the <code>getParserFor(String)</code> method of the <code>VllParsers</code> instance 
    to obtain a <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank">Parser</a> 
    for the top-level parser-rule (<i>Paycheck</i> in 
    the example being discussed here)</li>
  <li>Invoke the top-level parser-rule (Parser from the previous step) as usual by calling 
    the <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">RegexParsers</a>.<code>parseAll(<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html" target="_blank">Parser</a>, 
    <a href="http://download.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" target="_blank">CharSequence</a>)</code> 
    method accessed via the <code>VllParsers</code> instance obtained in step-2 above</li>
</ol>

<p>
The example code below illustrates use of <a href="http://vll.java.net/">VisualLangLab</a>'s extremely simple and minimal API. 
Only the parts in red are based on the <a href="http://vll.java.net/">VisualLangLab</a> API. The parts in blue are merely using 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">RegexParsers</a>'s 
familiar interface. 
</p>

<pre><code>import java.io.File
<span style="color:red; font-weight: bold">import vll.core.VllParsers</span>

object ArithExprWithAPI {
  
  private def evalFactorAST(ast: Any): Float = ast match {
    case Pair(0, f: String) => f.toFloat
    case Pair(1, expr) => evalExprAST(expr)
  }
  
  private def evalTermAST(ast: Any): Float = ast match {
    case Array(factor, list: List[_]) => 
      var result: Float = evalFactorAST(factor)
      list.foreach(_ match {
          case Pair(0, multAST) => result *= evalFactorAST(multAST)
          case Pair(1, divAST) => result /= evalFactorAST(divAST)
        })
      result
  }
  
  private def evalExprAST(ast: Any): Float = ast match {
    case Array(term, list: List[_]) => 
      var result: Float = evalTermAST(term)
      list.foreach(_ match {
          case Pair(0, plusAST) => result += evalTermAST(plusAST)
          case Pair(1, minusAST) => result -= evalTermAST(minusAST)
        })
      result
  }

  def main(args: Array[String]) {
    val vll = <span style="color:red; font-weight: bold">VllParsers.fromFile</span>(new File("ArithExpr.vll"))
    val parser = vll.<span style="color:red; font-weight: bold">getParserFor</span>("Expr")
    val parseResult = vll.<span style="color:blue; font-weight: bold">parseAll</span>(parser, "(3 + 5) / (8 - 4)")
    parseResult match {
      case vll.<span style="color:blue; font-weight: bold">Success</span>(resultAST, _) => println(evalExprAST(resultAST))
      case vll.<span style="color:blue; font-weight: bold">Failure</span>(msg, where) => printf("Error: '%s' at line %d col %d%n", 
          msg, where.pos.line, where.pos.column)
    }
  }
}
</code></pre>

<p>
Observe how the code navigates and interprets the parse-tree returned from <code>parseAll()</code>. 
The <a href="ASTAndActionCode.html#ASTStructure" target="_blank">AST structure</a> of each grammar-tree can 
be seen in the text area under <i>Parse Tree (AST) Structure</i>. 
</p>

<p>
Note that the API needs to load the saved grammar file from disk (see the line with 
the <code>VllParsers.fromFile()</code> call). The grammar-file for this example can be 
obtained by selecting the <i>ArithExpr</i> sample grammar (invoke <i>Help -> Sample 
grammars -> ArithExpr</i> from the <a href="http://vll.java.net/">VisualLangLab</a> main menu, then invoke <i>File -> 
Save As</i> and enter <i>ArithExpr.vll</i> for the filename). 

The API also provides other variants of this function that may be convenient in other 
situations:
</p>

<ul style="list-style-type: disc;">
  <li><code>VllParsers.fromString(java.lang.String)</code> - when the gramamar is available as a String</li>
  <li><code>VllParsers.fromXml(scala.xml.Elem)</code> - when the gramamar is available as an XML element</li>
</ul>

<p>
Either <i>VLLS.jar</i> or <i>VLLS-All.jar</i> must be on the classpath when 
compiling and running this code. You can see some more examples of the use of the API in 
<a href="UsingTheAPI.html" target="_blank">Using the API</a>. 
</p>

<h2 id="RegexParsersCompatibility">Scala Parser Combinator Compatibility</h2>

<p>
The class diagram in Figure-20 below depicts 
<a href="http://vll.java.net/" target="_blank">VisualLangLab</a>'s relationship with Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/package.html" target="_blank">
parser combinators</a>. Although it depends on <code>RegexParsers</code>, it changes 
most of the functionality by overriding many of the important methods.
</p>

<p>
<img src="images/RelationshipWithScalaParserCombinators.png" alt="Relationship With Scala Parser Combinators" /><br />
<i>Figure-20. Relationship With Scala Parser Combinators</i>
</p>

<p>
Full details of how VisualLangLab uses Scala's parser combinator library can be seen in 
<a href="RelationshipWithScalaParserCombinators.html" target="_blank">
Relationship with Scala Parse rCombinators</a>. 
</p> 

<h3 id="BuiltinLexicalAnalyzer">Builtin Lexical Analyzer</h3>

<p>
VisualLangLab overrides the <code>literal(String)</code> and <code>regex(Regex)</code> methods 
of Scala's 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
RegexParsers</a> with versions that work with a built-in lexer. The behavior of these 
versions is similar to lexers in more sophisticated parser development tools, and is described in 
<a href="RelationshipWithScalaParserCombinators.html#ClassSimpleLexingRegexParsers" target="_blank">
Simple Lexing RegexParsers</a>. 
</p>

<h3 id="JavaTokenParsers">JavaTokenParsers</h3>

<p>
Many example parsers in tutorials and other resources extend 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">
JavaTokenParsers</a>, so VisualLangLab provides a token library in it's place. 
Those planning to use this token library should, however, note that the tokens defined in 
it have names ending in an underscore (_). Ending the name of a token in an underscore causes 
VisualLangLab's built-in lexer to be bypassed, in favor of the 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">RegexParsers</a> 
capability. 
</p>

<p>
This change is required because the builtin lexer works best when the regex 
definitions are distinct, and multiple regex tokens will not match the same lexeme. 
But the regular expressions used in 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/JavaTokenParsers.html" target="_blank">
JavaTokenParsers</a> are such that <code>floatingPointNumber</code> subsumes both <code>decimalNumber</code> 
and <code>wholeNumber</code>, and <code>decimalNumber</code> itself subsumes <code>wholeNumber</code>. 
</p>

<h2 id="ProsAndCons">Pros and Cons</h2>

<p>
The table below lists the pros and cons of using VisualLangLab compared with 
a hand-written parser based on Scala parser combinators.
</p>

<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
      <th style="text-align: center; font-weight: bold;">Aspect</th>
      <th style="text-align: center; font-weight: bold;">Pros</th>
      <th style="text-align: center; font-weight: bold;">Cons</th>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="2" style="text-align: center; padding: 2px">Visual</td>
    <td style="padding: 2px">Completely visual. Code never required, except if semantic 
        predicates are used (but they are rare)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">All IDE functions provided - file, edit (tokens, rules, globals), test-run, input-output </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="5" style="text-align: center; padding: 2px">Lexical Analyzer</td>
    <td style="padding: 2px">The builtin lexer works like <a href="http://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">
        lexical analyzer generators</a>, but does not require any separate steps or tools</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Token definitions may use the full regular-expression language of the JDK's 
        <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank">Pattern</a></td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Unlike 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a>, all literal tokens are treated as <i>reserved keywords</i> that have higher priority 
        than regex tokens. The next lexeme provided by the lexer is always the longest possible part of the 
        input that matches any known token</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px"><a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a> compatible behavior can also be obtained if required</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Performance is probably poorer than 
        <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html" target="_blank">
        RegexParsers</a> though no measurements have been made</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">AST</td>
    <td style="padding: 2px">Defined and created automatically following a well-defined and documented 
        convention for AST structure. The AST is complete and unambiguous, and captures 
        every detail of how the input matched the grammar</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The AST is defined using common types from the Scala API, so no specialized 
        knowledge is needed when using AST from Scala. Programs in other JVM languages can obtain a 
        version of the AST constructed from JVM types only (release 6.01+). </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">All elements in the AST are amenable to Scala pattern matching, 
        so AST processing is simple. Programs in other JVM languages have to deal with a mutually 
        nested structure of arrays and lists. </td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr>
    <td rowspan="4" style="text-align: center; padding: 2px">Action Code</td>
    <td style="padding: 2px">Completely separated from grammar text. Written as function literals 
        invoked in a well-defined and documented protocol. 
        Action code functions may access their environment via a defined and 
        documented set of predefined <i>global</i> variables.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Option of languages: Scala and Javascript</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Never required to be embedded in parser text</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Lexical context of the parser is not available to action code. 
        However, since this restricts the action-code to its own <i>sand-box</i> it can be 
        seen as an an advantage too. </td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="4" style="text-align: center; padding: 2px">RegexParsers Compatibility</td>
    <td style="padding: 2px">Provides token libraries for JavaTokenParsers</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr bgcolor="#dddddd">
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Defines two layers (SimpleLexingRegexParsers an Aggregates) 
        which value-add to RegexParsers's capabilities</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">The usual RegexParses interface is exposed to API users</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="text-align: center; padding: 2px">-</td>
    <td style="padding: 2px">Not directly compatible, and such code can not be generated</td>
  </tr>

  <tr>
    <td rowspan="4" style="text-align: center; padding: 2px">API</td>
    <td style="padding: 2px">Parser developed in the VisualLangLab IDE may be saved to a file, and 
        subsequently used from a host program via the API</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API usable from any JVM language (release 6.01+)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">Parser does not have to be compiled or linked into host program.
        The parser can even be modified separately without affecting the host program 
        (provided the AST structure is not changed)</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr>
    <td style="padding: 2px">API based on the familiar RegexParsers interface for convenience</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>

  <tr bgcolor="#dddddd">
    <td rowspan="3" style="text-align: center; padding: 2px">Testing</td>
    <td style="padding: 2px">Includes comprehensive builtin support for ad hoc testing. 
        No additional tools, code, or skills are required.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Test drivers for black-box testing are easily created and run within 
        the IDE</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
  <tr bgcolor="#dddddd">
    <td style="padding: 2px">Any (or all) rules can be trace-enabled at the click of a button. 
        Even individual grammar-tree nodes can be traced.</td>
    <td style="text-align: center; padding: 2px">-</td>
  </tr>
</table>

  </body>
</html>
