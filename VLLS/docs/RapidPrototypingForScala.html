<html>
  <head>
    <title>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</title>
  </head>

  <body>

<h1>VisualLangLab - Rapid Prototyping for Scala Parser Combinators</h1>

<p>
<a href="http://vll.java.net/">VisualLangLab</a> is a visual parser-generator 
IDE for developing parsers without code or scripts of any kind. 
Parser-rules are depicted as 
visual <i>grammar-trees</i> with intuitive icons for different nodes types. 
The following figures show how it represents some rules of the payroll-parser 
external DSL described on page 240 of <a href="http://programmingscala.com/">Programming Scala</a>. 
The same code can also be found online at 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl">
Generating Paychecks with the External DSL</a>. 
<!-- 
The icons and annotations are explained fully in 
<a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>. 
--> 
</p>

<p>
<table border="1" cellpadding="1" style="border: 1px solid black; padding: 1px;"><tbody>
  <tr>
    <th style="text-align: center; font-weight: bold;">amount</th>
    <th style="text-align: center; font-weight: bold;">days</th>
    <th style="text-align: center; font-weight: bold;">deductItems</th>
    <th style="text-align: center; font-weight: bold;">deductKind</th>
  </tr>
  <tr>
    <td><img src="images/amount.png" /></td>
    <td><img src="images/days.png" /></td>
    <td><img src="images/deductItems.png" /></td>
    <td><img src="images/deductKind.png" /></td>
  </tr>
</tbody></table>
<i>Figure-1. Some VisualLangLab grammar-trees</i>
</p>


<p>
The grammar-trees are <i>executable</i>, and can be run at any time at the click of a button. 
No other skills or tools are needed. 
<!-- 
Input for the parser can be entered into the IDE or obtained from user-nominated files. 
-->
This simplifies <a href="#Testing">testing</a>, promotes an iterative-incremental development process, 
and speeds up development manyfold.
<!-- 
Optional <i>actions</i> &mdash; <a href="#ActionCode">snippets of code</a> in Javascript or Scala &mdash; 
can also be embedded in the grammar. 
-->
</p>

<p>
The grammar is saved as a XML file that can be reloaded for further 
<a href="EditingTheGrammarTree.html">editing</a> and 
<a href="#Testing">testing</a>. 
An <a href="UsingTheAPI.html">API</a> enables client programs (Scala or Java) 
to load the XML file and regenerate the parser. 
</p>

<p>
Each grammar-tree <i>is</i> a parser. There is no generated-code or other underlying code representation. 
VisualLangLab uses Scala's parser 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">combinator functions</a> 
to turn each grammar-tree directly into a 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a> 
at run-time as needed. Parser generation is therefore much faster than a code-based approach. 
</p>

<p>
In this tutorial we recreate the 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#AScalaImplementationExternalDSLGrammar">
payroll DSL</a> using <a href="http://vll.java.net/">VisualLangLab</a>, 
highlighting its features for parser development and testing.
</p>

<h3>Some Essential Jargon</h3>

<ul style="list-style-type: disc;">
  <li><i>parser</i> (with lower-case inital <i>p</i>) - in VisualLangLab documentation, 
    a parser is an <i>entire</i> program or function for 
    <a href="http://en.wikipedia.org/wiki/Parsing#Parser">parsing and processing input</a> 
     in a certain format. </li>
  <li><i>parser-rule</i> - the 
    <a href="http://en.wikipedia.org/wiki/Formation_rule">simpler units</a> 
    into which a parser is normally broken down. 
    In a Scala combinator-based parser, each <code>def ... : Parser[...] = ...</code> 
    is a parser rule. Parser-rule and grammar-tree are generally synonymous terms.</li>
  <li><i>grammar-tree</i> - the visual tree used to represent each parser-rule 
    in VisualLangLab. Grammar-tree and parser-rule are generally synonymous terms.</li>
  <li><i>Parser</i> (with upper-case inital <i>P</i>) - a Scala 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">type</a> used to 
    implement <i>parser-rule</i>s as well as the component nodes of parser-rules</li>
</ul>

<h2>Download and Run VisualLangLab</h2>

<p>
To run VisualLangLab, just download 
<a href="http://java.net/projects/vll/downloads/download/VLLS-All.jar">VLLS-All.jar</a> 
and double-click it in a file-browser. Linux and UNIX users will have to enable execution 
(<i>chmod +x ...</i>) first. 
Another file, <a href="http://java.net/projects/vll/downloads/download/VLLS.jar">VLLS.zip</a>, 
which contains the documentation files, sample grammars, etc. should also be downloaded.
</p>

<p>
When started, VisualLangLab displays the GUI shown in Figure-2 below. 
The menus and buttons are explained as needed, but a full 
description can also be found at 
<a href="TheGUI.html">The GUI</a>. 
All toolbar buttons have tool-tip texts that explain their use. 
</p>

<p>
<img src="images/GuiFull3.png" /><br />
<i>Figure-2. The VisualLangLab GUI</i>
</p>

<p>
The graphical and text panels are used as described below.
</p>

<ul style="list-style-type: disc;">
  <li>A is used for the grammar-tree as described in 
      <a href="#CreatingParserRules">Creating the Parser-Rules</a> below</li>
  <li>B displays the <a href="ASTAndActionCode.html#ASTStructure">AST structure</a> 
      of the selected grammar-tree node</li>
  <li>C is where the selected node's <a href="#ActionCode">action-code</a> 
      (<i>semantic action</i>, or just <i>action</i>) is displayed and edited. 
      If this appears to break the 
      <i>no code, no script</i> promise, rest assured that action-code 
      is always optional</li>
  <li>D and E are used for <a href="#Testing">testing the parser</a> 
      as described below</li>
</ul>

<p>
The only prerequisite for running VisualLangLab as described above is a 
<a href="http://www.oracle.com/technetwork/java/javase/overview/index-jsp-136246.html">6.0+ JRE</a>. 
But if you want to use the VisualLangLab 
<a href="#APICodeGeneration">API</a> to develop standalone applications, a 
<a href="http://www.scala-lang.org/downloads">2.9.0+ Scala</a> installation is required. 
</p>

<h2 id="CreatingParserRules">Creating the Parser-Rules</h2>

<p>
In the <a href="http://programmingscala.com/">book</a>, 
the parser <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl">code</a> 
is organized in top-down fashion. 
We start at the bottom, with <i>doubleNumber</i>, 
and work our way up, creating some of the parser-rules so as to 
demonstrate most of VisualLangLab's features. The complete parser is, 
however, included as the file <i>payroll-parser-comb.vll</i> in the 
<i>grammars</i> directory of the zip distribution. 
</p>

<h3>Import Required Tokens</h3>

<p>
Your first step is to import the tokens in <code>JavaTokenParsers</code>, and VisualLangLab 
provides a corresponding <i>token library</i> containing these tokens. 
Select <i>Tokens -> Import tokens</i> from the main menu, or click the <i>Import tokens</i> 
(<img src="images/Import16.gif" align="center"/>) button, and choose the file 
<i>grammars/TL-JavaTokenParsers.vll</i> from the contents of <i>VLLS.zip</i>.
</p>

<p>
(<b>The description in this paragraph is not yet complete</b>) 
Also note that because of differences between Scala's <a href="">RegexParsers</a> 
and VisualLangLab's <a href="">internal lexer</a>, we shall be substituting the 
token <code>decimalNumber</code> wherever <code>floatingPointNumber</code> was used 
in the original code. 
</p>

<h3>def doubleNumber = floatingPointNumber ...</h3>

<p>
This is a very simple parser-rule, and matches just one unconditional token. 
But as mentioned above, we will modify this parser definition, and implement 
it as the following line instead.
</p>

<pre></code>    def doubleNumber = decimalNumber
</code></pre>

<p>
To create the new rule click the <i>New rule</i> button 
(<img src="images/NewReference.gif" align="center"/>), 
and enter <i>doubleNumber</i> into the dialog box presented as in Figure-3 below. 
Clicking the dialog's <i>OK</i> button creates a new rule with just the 
<i>Root</i> node (<img src="images/GrammarIconRoot.gif" align="center"/>)</li>.
</p>

<p>
<img src="images/CreateRule-doubleNumber.png" /><br />
<i>Figure-3. Creating the </i>doubleNumber<i> parser-rule</i>
</p>

<p>
Now right-click the Root node, and select <i>Add -> Token</i> from the popup 
context-menu. Another dialog with all the known token names is presented 
as in Figure-4 below. 
Select <i>decimalNumber</i> and click the <i>OK</i> button</li>
</p>

<p>
<img src="images/AddToken-decimalNumber.png" /><br />
<i>Figure-4. Selecting the </i>decimalNumber<i> token</i>
</p>

<p>
Finally, select (click) the <i>decimalNumber</i> token 
(<img src="images/GrammarIconRegex.gif" align="center" />), and paste the Scala function 
given below into the text area under <i>Action Code</i> as in Figure-5 
below. Click the <i>Save</i> button. 
</p>

<pre><code>    (a: Any) => a match {
      case null =>
      case d: String => d.toDouble
    }</code></pre>

<p>
The action-code function is explained further in <a href="#ActionCode">Action Code</a> below. 
Your finished parser should look like the Figure-5 below. 
</p>

<p>
<img src="images/Action-doubleNumber.png" /><br />
<i>Figure-5. Adding action-code to the </i>doubleNumber<i> rule</i>
</p>

<h3>def toBe = "is" | "are"</h3>

<p>
This parser-rule uses to custom literal tokens (<i>is</i> and <i>are</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New literal</i> button 
    (the <img src="images/ToolBarButtonNewLiteral.gif" align="center"/> icon), 
    enter <i>IS,is</i> into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-6 below)</li>
  <li>repeat the preceding action once more, but enter <i>ARE,are</i> instead</li>
</ul>

<p>
The information entered into the dialog when creating a literal contains the 
literal's <i>name</i>, and its <i>pattern</i> separated by a comma.
You can optionally add spaces around the comma for clarity if required. 
The <i>name</i> is used to refer to the literal in rules (as 
shown below), while the <i>pattern</i> is it's literal definition. 
</p>

<p>
<img src="images/NewLiteral-IsAre.png" /><br />
<i>Figure-6. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
This parser uses a <i>Choice</i> 
(the <img src="images/GrammarIconChoice.gif" align="center"/> icon) as its top-level node. 
A <i>Choice</i> node is a parent of a group of alternatives (any one of which may occur 
in the input). To create the parser, perform the following steps.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>toBe</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) and select 
    <i>Choice</i> from the context menu. A <i>Choice</i> node 
    (<img src="images/GrammarIconChoice.gif" align="center"/>) is added to the root node
    (as in the left and middle parts of Figure-7 below)</li>
  <li>right-click the newly created choice node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is popped up. 
    Select <i>IS</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the prceding action, but select the token <i>ARE</i> instead</li>
</ul>

<p>
Your <i>toBe</i> parser should now look like the one on the right side of Figure-7 below. 
</p>

<p>
<img src="images/CreateRule-toBe.png" /><br />
<i>Figure-7. The </i>toBe<i> parser</i>
</p>

<p>
The grammar-tree's node icons are designed to be intuitive, but you can find a 
guide to all the icons in 
<a href="EditingTheGrammarTree.html#GrammarTreeIconsAndAnnotations">Grammar Tree Icons and Annotations</a>
</p>

<h3>def percentage = toBe ~> doubleNumber <~ "percent" <~ "of" <~ "gross" ...</h3>

<p>
This parser uses a <i>Sequence</i> 
(the <img src="images/GrammarIconSequence.gif" align="center"/> icon) as its top-level node. 
A <i>Sequence</i> node is a parent of a set of nodes which occur 
in the input in the order specified. To create this parser, perform the following steps.</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>percentage</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) and select 
    <i>Sequence</i> from the context menu. A <i>Sequence</i> node 
    (<img src="images/GrammarIconSequence.gif" align="center"/>) is added to the root node</li>
  <li>right-click the newly created sequence node and select <i>Reference</i> from the context menu. 
    A dialog box with a dropdown list containing known parser-rule names is presented. 
    Select <i>toBe</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action once more, selecting the reference <i>doubleNumber</i> instead</li>
  <li>right-click the sequence node and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is presented. 
    Select <i>PERCENT</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action two more times, and add the tokens <i>OF</i> 
    and <i>GROSS</i> to the sequence node</li>
</ul>

<p>
Examining the arrows (<i>~></i> and <i><~</i>) in the <code>def</code>inition, 
we can deduce that only the result of matching <i>doubleNumber</i> is desired to 
be retained. All other tokens are to be dropped from the AST. You can <i>drop</i> 
tokens from the sequence's AST by right-clicking each node's icon and selecting 
<i>drop</i> from the context menu (as shown on the left side of the figure). 
Remember not to <i>drop</i> the <i>doubleNumber</i> token. 
Your finished parser-rule should now look like the left side of Figure-8 below.
</p>

<p>
<img src="images/Rule-percentage.png" /><br />
<i>Figure-8. The </i>percentage<i> parser-rule</i>
</p>

<p>
Observe that the icons of <i>drop</i>ped nodes are overlaid with a black line 
from the lower-left to the upper-right. The 
<a href="EditingTheGrammarTree.html#Annotations">annotation</a> <i>drop</i> is also added 
after the name of the node.
</p>

<p>
Select (click) the <i>Sequence</i> icon 
(<img src="images/GrammarIconSequence.gif" align="center"/>), and paste the Javascript function 
given below into the text area under <i>Action Code</i> (red rectangle on right side). 
Then click the <i>Save</i> button. 
</p>

<pre><code>    function (arg) {
      if (arg !== null) {
        return VLL.grossAmount * (arg / 100);
      }
    }</code></pre>

<p>
Though different from the original text, this action function is actually functionally 
equivalent, as explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser should look like the one on the right side of Figure-8 above. 
</p>

<h3>def days = "days?".r ...</h3>

<p>
This parser-rule uses a custom regex tokens (<i>days?</i>) which must be defined 
first. Proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New regex</i> button 
    (the <img src="images/ToolBarButtonNewRegex.gif" align="center"/> icon), 
    enter <i>DAYS,days?</i> into the dialog presented, and click the <i>OK</i> button 
    (as in Figure-9 below). In this case, the pattern is a regular-expression as 
    defined by the JDK's 
    <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">Pattern</a> 
    class</li>
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>days</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) 
    and select <i>Add -> Token</i> from the context menu. 
    Select <i>DAYS</i> from the dropdown list, and click the <i>OK</i> button</li>
</ul>

<p>
The information entered into the dialog contains the regex's <i>name</i>, 
and its <i>pattern</i> separated by a comma. 
As for literals, you can optionally add spaces around the comma for clarity. 
The <i>name</i> is used to refer to the literal in rules (as 
shown below), while the <i>pattern</i> is it's regular-expression specification. 
</p>

<p>
<img src="images/NewRegex-days.png" /><br />
<i>Figure-9. Creating the </i>is<i> and </i>are<i> tokens</i>
</p>

<p>
Select (click) the <i>DAYS</i> icon 
(<img src="images/GrammarIconRegex.gif" align="center"/>), and paste the Scala function 
given below into the text area under <i>Action Code</i> (red rectangle on right side). 
Then click the <i>Save</i> button. 
</p>

<pre><code>    (a: Any) => a match {
      case null =>
      case _ => 1
    }</code></pre>

<p>
Action-code function design and use is explained in <a href="#ActionCode">Action Code</a> below. 
Your finished parser should look like the one on the right side of Figure-9 above. 
</p>

<h2 id="AdHocTesting">Ad Hoc Testing - A Short Detour</h2>

<p>
A <a href="#Testing">full section</a> on testing comes later, 
this section demonstrates the simplicity and power of VisualLangLab's 
manual testing facilities. It shows how you can effortlessly 
validate every little addition or change without using or learning 
any other skills or tools. 
</p>

<h3>Validating doubleNumber</h3>

<p>
To manually test <i>doubleNumber</i> proceed as follows (refer Figure-10 below).
</p>

<ul style="list-style-type: disc;">
  <li>enter test input under <i>Parser Test Input</i> 
    (red rectangle at bottom left)</li> 
  <li>click the <i>Parse input</i> button (outlined in red)</li> 
  <li>validate the parser's result printed under <i>Parser Log</i> 
    (wide red rectangle at bottom right)</li> 
</ul>

<p>
If you do not see any red text (as in Figure-12 below) in the 
<i>Parser Log</i> area, your parser executed without run-time errors. 
But that alone is not enough, you should verify that the result returned 
(for example, <i>25.5</i> in Figure-10) is the value expected. 
</p>

<p>
<img src="images/testing-doubleNumber.png" /><br />
<i>Figure-10. Testing the </i>doubleNumber<i> parser</i>
</p>

<p>
The parser's <i>result</i> or AST is on the third line (after the <i>result follows:</i>). 
The previous two lines of output contain performance 
information that should be ignored. 
This test passes as <i>25</i> (last line under <i>Parser Log</i>) is the expected 
result. 
</p>

<h3>Validating toBe</h3>

<p>
Before you start to enter test data for <i>toBe</i> take a moment to understand 
the structure of its output. All parser rules return an 
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (or AST) 
whose structure depends on the arrangement and properties of the grammar-tree's constituent nodes 
as explained in <a href="ASTAndActionCode.html#ASTStructure">AST Structure</a>. 
The text area under <i>Parse Tree (AST) Structure</i> displays the expected AST 
structure of the selected grammar-tree node. Figure-11 below tells you that the returned 
result is one of two <code>scala.Pair</code> objects (depending on what was found in the input). 
</p>

<p>
<img src="images/AST-toBe.png" /><br />
<i>Figure-11. The AST of the </i>toBe<i> parser rule</i>
</p>

<p>
Figure-12 below shows the result of exercising <i>toBe</i> with three different 
inputs: <i>is</i>, <i>are</i>, and <i>other</i>. 
</p>

<table>
  <tr><td><img src="images/AST-toBe-is.png" /></td></tr>
  <tr><td><img src="images/AST-toBe-are.png" /></td></tr>
  <tr><td><img src="images/AST-toBe-other.png" /></td></tr>
  <tr><td><i>Figure-12. Validating </i>toBe<i> with different inputs</i></td></tr>
</table>

<p>
This set of tests too pass as all three test cases produce the expected result. 
</p>

<h2>Finishing with Parser-Rules</h2>

<p>
The remaining parsers, except one that uses a <code>repsep</code> and 
is described fully below, present no new difficulties and 
we leave them as an exercise for the reader. 
To save time, you may also just open the file <i>payroll-parser-comb.vll</i> 
in the <i>grammars</i> directory of the zip distribution. 
</p>

<h3>def deductItems = repsep(deductItem, ",")</h3>

<p>
This parser-rule uses a <i>RepSep</i> 
(the <img src="images/GrammarIconRepSep.gif" align="center"/> icon) as its top-level node. 
To create this rule proceed as follows.
</p>

<ul style="list-style-type: disc;">
  <li>click the <i>New rule</i> button (<img src="images/NewReference.gif" align="center"/>), 
    enter <i>deductItems</i> into the dialog presented, and click its <i>OK</i> button</li>
  <li>right-click the root node (<img src="images/GrammarIconRoot.gif" align="center"/>) and select 
    <i>RepSep</i> from the context menu (as on the left side of Figure-13 below). 
    A <i>RepSep</i> node 
    (<img src="images/GrammarIconRepSep.gif" align="center"/>) is added to the root node</li>
  <li>right-click the newly created repsep node and select <i>Reference</i> from the context menu. 
    A dialog box with a dropdown list containing known parser-rule names is presented. 
    Select <i>deductItem</i> from the dropdown list, and click the <i>OK</i> button</li>
  <li>repeat the preceding action, but select the reference <i>doubleNumber</i> instead</li>
  <li>right-click the repsep node again and select <i>Add -> Token</i> from the context menu. 
    A dialog box with a dropdown list containing known token names is presented. 
    Select <i>COMMA</i> from the dropdown list, and click the <i>OK</i> button</li>
</ul>

<p>
Your finished rule should look like the one on the right side of Figure-13 below. 
</p>

<p>
<img src="images/Rule-deductItems.png" /><br />
<i>Figure-13. The </i>deductItems<i> parser-rule</i>
</p>

<p>
If you did create <i>deductItems</i> you will notice a little red 'x' at 
the top-right corner of the rule's root node. 
This is the error flag, and making the mouse hover over the root-node 
displays the nature of the problem (in the tool-tip text). 
Both these features can be seen on the right side of Figure-13 above. 
</p>

<p>
The problem is that <i>deductItems</i> can return successfully without 
matching any input. But VisualLangLab forbids the use of such parser-rules 
as it is possible to create very obscure and difficult-to-diagnose errors 
with them. The solution, in this case, is quite simple &mdash; implant 
the contents of  <i>deductItems</i> directly into it's client rule 
(<i>deduct</i>). Figure-14 below shows the required modification of <i>deduct</i>. 
</p>

<p>
<img src="images/Rule-deduct-modified.png" /><br />
<i>Figure-14. Modifying the </i>deduct<i> rule</i>
</p>

<p>
In terms of the 
to the <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl">
original parser combinator code</a>, we made the following change. 
</p>

<pre><code>def deduct = "minus" ~> "deductions" ~> "for" ~> 
    "{" ~> <del>deductItems</del> <u>repsep(deductItem, "," )</u>  <~ "}"
<del>def deductItems = repsep(deductItem, "," )</del></code></pre>

<p>
Finally, select (click) the <i>RepSep</i> node 
(<img src="images/GrammarIconRepSep.gif" align="center" />), and paste the Scala function 
given below into the text area under <i>Action Code</i> as in Figure-15 below. 
Click the <i>Save</i> button. 
</p>

<pre><code>    (a:Any) => a match {
      case null =>
      case ld: List[Double] => ld.foldLeft(0.0){_ + _}
    }</code></pre>

<p>

The action-code function is explained further in <a href="#ActionCode">Action Code</a> below. 
Your finished parser should look like the Figure-15 below. 
</p>

<p>
<img src="images/Action-deductItems.png" /><br />
<i>Figure-15. Adding action-code to the </i>deductItems<i> rule</i>
</p>

<h3 id="SomeMoreTheory">Some more Theory</h3>

<p>
Remember that the grammar-trees <i>are</i> parser-rules. There is no generated-code or 
intermediate-code. VisualLangLab uses Scala's parser 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">combinator functions</a> to turn the grammar-tree directly into a 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a> at run-time without compiling any code. 
That is why the displayed parser-rule <i>runs</i> almost immediately when the 
<i>Parse input</i> button is clicked. 
</p>

<h2 id="ActionCode">Action Code</h2>

<p>
Action code is written as anonymous funtion literals in Scala or Javascript. 
Both languages can be mixed freely in a parser, but each function must be written in 
one of the forms shown below. Semantically equivalent abbreviated forms in Scala 
(using _ to imply the argument) are not allowed. 
The name of the argument and use of whitespace characters may, however, vary.
</p>

<table border="1" style="border: 1px solid black;">
  <tr><th>If in Scala</th><th>If in Javascript</th></tr>
  <tr><td><code>(arg: Any) => { ... }</code></td><td><code>function (arg) { ... }</td></tr>
</table>

<p>
The choice of language for the examples in this article is based on one criterion: 
presence of references to external objects. 
completely self-contained functions with no external references are coded in Scala, 
while those with external data or function references are coded in Javascript. 
You can find detailed guidelines at 
<a href="ASTAndActionCode.html#ActionCodeDesign">Action-Code Design</a>. 
</p>

<p>
In general, action code from the original 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#_generating_paychecks_with_the_external_dsl">
parser code</a> can not be used verbatim as VisualLangLab's 
<a href="ASTAndActionCode.html#ASTStructure">AST structure</a> differs in many cases.  
A few examples of action-code functions in Scala and Javascript are shown below. 
Observe that grammar-tree nodes with associated action-code have the 
<i>action</i> attribute marked next to the node's icon. To see the 
action-code you have to select (click) the specific node. 
</p>

<h3 id="ExternalResources">External Resources</h3>

<p>
Because action-code functions execute in a closed environment, 
it is difficult to load and use custom classes (like 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_here_is_the_simple_paycheck_">
Paycheck</a>, 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_the_money_type_handles_arith">
Money</a>, etc.). This is where Javascript's dynamic features help. 
As shown in <a href="#WrapperWithActions">Wrapper With Actions</a> 
below, those features can be used to create Javascript objects and methods 
to substitute the missing native (Scala or Java) resources. 
This approach is frequently adequate in a limited context such as testing. 
More exacting situations that must load external classes must be handled via 
the <a href="#APICodeGeneration">API</a>. 
</p>

<h3 id="ScalaActionCodeWeekDays">Scala Action-Code: weekDays</h3>

<p>
The purpose of this rule is to check its input, and return the integer 5 if either 
<i>weeks</i> or <i>week</i> is found, and the integer 1 if <i>days</i> or <i>day</i> 
is found. As described in <a href="#ActionCode">Action Code</a> below, 
action-code functions must handle two cases: a <i>null</i> argument, and a non-null 
<i>real</i> AST argument. For this grammar, only the function in 
<a href="#WrapperWithActions">Wrapper with Actions</a> below needs to handle 
the <i>null</i>-argument case.  
</p>

<p>
To understand the logic of the action-code you must 
know the structure of the AST passed in (as the argument <i>a</i>). 
The AST structure is depicted in the text area under the 
<i>Parse Tree (AST) Structure</i> label. 
<a href="ASTAndActionCode.html#ASTStructure">AST Structure</a> describes 
AST structuring principles in general. 
</p>

<p>
<img src="images/Action-weekDays.png" /><br />
<i>Figure-16. A Scala action-code function</i>
</p>

<p>
The structure and action-code of the two subordinate rules it uses 
(<i>weeks</i> and <i>days</i>) is shown in Figure-17 below. 
</p>

<p>
<table>
  <tr><td><img src="images/Action-weeks.png" /></td></tr>
  <tr><td><img src="images/Action-days.png" /></td></tr>
</table>
<i>Figure-17. Action functions of weeks and days rules</i>
</p>

<p>
Since <i>weekDays</i>' subordinate rules return the required values (5 and 1), 
its own action-code only needs to pass on the value recieved. Based on the 
above details we know that the AST passed in to <i>weekDays</i> is one of 
these two values: <code>Pair(0,5)</code>, and <code>Pair(0,1)</code> (the 
second member being the value from the subordinate rules). 
So <i>weekDays</i> merely needs to return the second member of the <code>Pair</code>. 
</p>

<h3 id="JavascriptActionCodePercentage">Javascript Action-Code: percentage</h3>

<p>
Figure-18 below illustrates the action-code associated with the rule <i>percentage</i>. 
This function uses a non-local reference <code>VLL.grossAmount</code>. 
As described in <a href="ASTAndActionCode.html#ActionCodeDesign">Action-Code Design</a>, 
the symbol <code>VLL</code> refers to a common global object available to all action-code 
functions, and should be used as a repository for all parser-specific features (methods and 
functions) and state (data). <a href="#WrapperWithActions">Wrapper With Actions</a> below 
illustrates how <code>VLL</code> is equipped with required features before 
testing begins. 
</p>

<p>
<img src="images/Action-percentage.png" /><br />
<i>Figure-18. A Javascript action-code function</i>
</p>

<p>
The function does not have any setting-up role, so does not have to handle the 
<code>(arg == null)</code> case. The value of <code>arg</code> it receives is the 
output from the rule <i>doubleNumber</i> (see AST structure) which is a 
<code>double</code> value. It computes and returns the required value. 
</p>

<h2 id="Testing">Testing</h2>

<p>
Testing is much simpler in VisualLangLab than in almost every other tool. 
<a href="#AdHocTesting">Ad Hoc Testing - A Short Detour</a> showed 
how effective ad hoc manual testing can be in certain situations. 
VisualLangLab also supports automated testing, and the following  
sections describe two different approaches for different situations. 
</p>

<h3 id="WrapperWithActions">Wrapper with Actions</h3>

<p>
This approach uses an additional parser-rule to <i>wrap</i> the main 
(or top-level) parser-rule with <i>before</i> and <i>after</i> scripts.
The <i>before</i> script sets up initial conditions before the main 
parser-rule is invoked, and the <i>after</i> script validates the parse-tree 
returned by the main parser-rule. 
Figure-19 below shows details of the wrapper rule used for testing. 
To display the <i>before</i> and <i>after</i> scripts (actually 
parts of a single action-code function) you must select (click on)
the <i>Reference</i> node that points to the <i>Paycheck</i> parser-rule. 
</p>

<p>
<b>If you have not read <a href="ASTAndActionCode.html#ActionCodeDesign">
Action-Code Design</a> and <a href="ASTAndActionCode.html#ASTStructure">AST Structure</a>, 
please do so now!</b>
</p>

<p>
<img src="images/Action-PaycheckTester.png" /><br />
<i>Figure-19. Wrapper rule for automated testing</i>
</p>

<p>
The Javascript function with the before and after scripts is reproduced below for clarity. 
The setup part of the function performs two functions.
</p>

<ul style="list-style-type: disc;">
  <li>sets up the data-member <code>grossSalary</code>, and creates the 
    method <code>salaryForDays</code> in the global object <code>VLL</code></li>
  <li>deposits a few lines of test input (from 
    <a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_let_s_try_it_out_here_is_a_sp">here</a> in 
    the OFPS version of <i>Programming Scala</i>) into the <i>Parser Test Input</i> area. 
    These lines are processed as input when the main parser-rule runs</li>
</ul>

<p>
The test part of the code checks the structure 
of the parse-tree returned by the main parser, and prints out an appropriate message. 
</p>

<pre><code>function (arg) {
  if (arg === null) {
//****************************************
//          SETUP actions
//****************************************
  // global variables and functions ...
    VLL.grossSalary = 500.0
    VLL.salaryForDays = function (days) {
      return VLL.grossSalary * days;
    }
  // Input text for parser ...
    ParserTestInput.setText(
      "paycheck for employee \"Buck Trends\"\n" +
      "is salary for 2 weeks minus deductions for {\n" +
      "  federal income tax is 25. percent of gross,\n" +
      "  state income tax is 5. percent of gross,\n" +
      "  insurance premiums are 500. in gross currency,\n" +
      "  retirement fund contributions are 10. percent of gross\n" +
      "}"
    )
  } else {
//****************************************
//          TEST actions
//****************************************
    if (arg.length === 3) {
      var error = ""
      var empl = arg[0];
      if (empl !== "Buck Trends") {
        error += "BAD empl, "
      }
      var gross = arg[1];
      if (gross !== 5000) {
        error += "BAD gross, "
      }
      var deduct = arg[2];
      if (deduct !== 2500) {
        error += "BAD deduct"
      }
      if (error === "") {
        return "OK";
      } else {
        return error;
      }
    } else {
      return "BAD AST structure";
    }
  }
}</code></pre>

<p>
To understand how this works, let's run it a few times with and 
without changes to the test input. The underlined part is the 
changed text (in the table). To run the test after making changes 
in the action-code click the <i>Save</i> button and wait for 
a pop-up dialog to confirm that the change was accepted, click 
the pop-up's <i>OK</i> button, and then click the <i>Parse input</i> 
(<img src="images/ToolBarButtonParseInput.gif" align="center"/>) button. 
</p>

<table border="1" style="border: 1px solid black;">
  <tr>
    <th style="text-align: center; font-weight: bold;">Input Changes</th>
    <th style="text-align: center; font-weight: bold;">Result</th>
  </tr>
  <tr>
    <td>No changes</td>
    <td>OK</td>
  </tr>
  <tr>
    <td>... employee "<u>D</u>uck Trends" ...</td>
    <td>BAD empl, </td>
  </tr>
  <tr>
    <td>... salary for 2<u>2</u> weeks minus ...</td>
    <td>BAD gross, BAD deduct,</td>
  </tr>
  <tr>
    <td>... premiums are <u>9</u>00. in ...</td>
    <td>BAD deduct</td>
  </tr>
</table>

<p>
Near the top of the script, a value called <i>ParserTestInput</i> is 
used. This name is a reference to the GUI's <code>JTextArea</code> 
from which the parser under test obtains input (and into 
which test input is normally entered manually). More information about 
this can be found under <a href="ASTAndActionCode.html#PredefinedVariables">
Predefined Variables</a>. 
</p>

<h3 id="TestingWithJUnit">JUnit + API</h3>

<p>
The example code below illustrates a JUnit test case that exercises two of the 
parser-rules (<i>weekDays</i> and <i>Paycheck</i>) in the parser we created earlier. 
The code uses the <a href="#APICodeGeneration">VisualLangLab API</a> (red lines), 
as well as the <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">
RegexParsers</a> interface (blue lines). The code uses the API to regenerate the parser 
from a saved grammar file. 
The grammar file used (<i>payroll-parser-comb-noaction.vll</i>) is a modified version of 
the parser described above that has all the action-code removed. Using a grammar without any 
actions gives better better insight into the overall process, and results in more precise 
tests.
</p>

<p>
The test-case includes one test for each of the two 
parser-rules mentioned above.The test for <i>weekDays</i> has six separate checks. The first four checks verify 
that the rule accepts <i>week</i>, <i>weeks</i>, <i>day</i>, and <i>days</i>, and returns 0, 
0, 1, and 1 respectively. The last two checks verify that it does not accept 
<i>daily</i> and <i>weekly</i>. 
The test for <i>Paychecks</i> has two checks &mdash; one without deductions and another 
with deductions. The data for these checks is from 
<a href="http://ofps.oreilly.com/titles/9780596155957/DomainSpecificLanguages.html#c_para_the_following_specification_w">
the code on pages 243 and 244</a> of 
<a href="http://programmingscala.com/">the book</a>. 
</p>

<pre><code>import java.io.File
import org.junit.Test
import org.junit.Assert._
import org.junit.runner.JUnitCore
<span style="color:red">import vll.core.VllParsers</span>
import scala.collection.JavaConversions._

class PayrollDSLTest {
  val withDeductions = """paycheck for employee "Buck Trends"
          |is salary for 2 weeks minus deductions for {
          |  federal income tax is 25. percent of gross,
          |  state income tax is 5. percent of gross,
          |  insurance premiums are 900. in gross currency,
          |  retirement fund contributions are 10. percent of gross
          |}""".stripMargin
  val noDeductions = """paycheck for employee "Buck Trends"
          |is salary for 2 weeks minus deductions for {
          |}""".stripMargin
  
  val vllParsers = <span style="color:red">VllParsers.fromFile</span>(new File("payroll-parser-comb-noaction.vll"))
  
  @Test def weekDays() {
    val parser = <span style="color:red">vllParsers.getParserFor</span>("weekDays")
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, "week") match 
        {case <span style="color:blue">vllParsers.Success</span>(Pair(0, "week"), _) => true; case _ => false})
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, "weeks") match 
        {case <span style="color:blue">vllParsers.Success</span>(Pair(0, "weeks"), _) => true; case _ => false})
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, "day") match 
        {case <span style="color:blue">vllParsers.Success</span>(Pair(1, "day"), _) => true; case _ => false})
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, "days") match 
        {case <span style="color:blue">vllParsers.Success</span>(Pair(1, "days"), _) => true; case _ => false})
    assertFalse(<span style="color:blue">vllParsers.parseAll</span>(parser, "daily") match 
        {case <span style="color:blue">vllParsers.Success</span>(_, _) => true; case _ => false})
    assertFalse(<span style="color:blue">vllParsers.parseAll</span>(parser, "weekly") match 
        {case <span style="color:blue">vllParsers.Success</span>(_, _) => true; case _ => false})
  }
  
  @Test def paycheck() {
    val parser = <span <span style="color:red">vllParsers.getParserFor</span>("Paycheck")
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, noDeductions) match {
        case <span style="color:blue">vllParsers.Success</span>(Array("\"Buck Trends\"", 
            Array("2", Pair(0, "weeks")), Nil), _) => true
        case _ => false})
    assertTrue(<span style="color:blue">vllParsers.parseAll</span>(parser, withDeductions) match {
        case <span style="color:blue">vllParsers.Success</span>(Array("\"Buck Trends\"", 
            Array("2", Pair(0, "weeks")), List(Pair(0, "25."), Pair(0, "5."), 
            Pair(1, "900."), Pair(0, "10."))), _) => true
        case _ => false})
  }
}</code></pre>

<p>
The tests use Scala's pattern-matching capability to verify the structure of the parse-tree 
returned by the parser. The redability of the AST verifying code is enhanced by the fact that 
the convention used for <a href="ASTAndActionCode.html#ASTStructure">AST Structure</a> uses standard classes from the Scala API. 
</p>

<h2 id="APICodeGeneration">The API, Code-Generation, etc.</h2>

<p>
One of the first questions that most people have is <i>how do I generate 
the parser code</i>? The short answer is <i>you can't</i>; a somewhat 
longer one is <i>you don't have to</i>. Here's why:
</p>

<p>
VisualLangLab never generates any parser code &mdash; not even for its own 
internal use. It uses the capabilities of 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html"> 
Parser</a> and 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html"> 
RegexParsers</a> to produce 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html"> 
Parser</a> instances <i>directly</i> from grammar-trees at run-time 
without generating or compiling any code. The Parsers produced have all the features 
and properties assigned to the grammar-trees by VisualLangLab's grammar-tree editor. 
The same Parser-generation procedure is available to host programs through the 
<a href="UsingTheAPI.html">VisualLangLab API</a>. 
To use a Parser from a (Scala or Java) program, proceed as follows.
</p>

<ol style="list-style-type:decimal;">
  <li>In the VisualLangLab GUI, save the grammar to a file by invoking <i>File -> Save</i> or 
    <i>File -> SaveAs</i></li>
  <li>In a the client program, use the API's <code>VllParsers.fromFile(java.io.File)</code> function 
    to create an instance of <code>vll.core.VllParsers</code>. This class extends the Scala API's 
    <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a>, 
    but has some additional VisualLangLab-specific features illustrated below</li>
  <li>Use the <code>getParserFor(String)</code> method of the <code>VllParsers</code> instance 
    to obtain a <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a> 
    for the top-level parser-rule (<i>Paycheck</i> in 
    the example being discussed here)</li>
  <li>Invoke the top-level parser-rule (Parser from the previous step) as usual by calling 
    the <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a>.<code>parseAll(<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers$Parser.html">Parser</a>, 
    <a href="http://download.oracle.com/javase/6/docs/api/java/lang/CharSequence.html">CharSequence</a>)</code> 
    method accessed via the <code>VllParsers</code> instance obtained in step-2 above</li>
</ol>

<p>
The example code below illustrates use of VisualLangLab's extremely simple and minimal API. 
Only the parts in red are based on the VisualLangLab API. The parts in blue are merely using 
<a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/RegexParsers.html">RegexParsers</a>'s 
familiar interface. 
</p>

<pre><code>import java.io.File
<span style="color:red">import vll.core.VllParsers</span>

object ApiDemo {
  def main(args: Array[String]) {
  val payDSL = """paycheck for employee "Buck Trends"
          |is salary for 2 weeks minus deductions for {
          |  federal income tax is 25. percent of gross,
          |  state income tax is 5. percent of gross,
          |  insurance premiums are 900. in gross currency,
          |  retirement fund contributions are 10. percent of gross
          |}""".stripMargin
    val vllParsers = <span style="color:red">VllParsers.fromFile</span>(new File("payroll-parser-comb-pure.vll"))
    val parser = <span style="color:red">vllParsers.getParserFor</span>("Paycheck")
    <span style="color:blue">vllParsers.parseAll</span>(parser, payDSL) match {
        case <span style="color:blue">vllParsers.Success</span>(Array("\"Buck Trends\"", 
            Array("2", Pair(0, "weeks")), List(Pair(0, "25."), Pair(0, "5."), 
            Pair(1, "900."), Pair(0, "10."))), _) => println("Ok !")
        case <span style="color:blue">vllParsers.NoSuccess</span>(msg, _) => println("Error: + msg")
      }  
    <span style="color:blue">vllParsers.parseAll</span>(parser, "weekly") match {
        case <span style="color:blue">vllParsers.Success</span>(_, _) => println("Ok !")
        case <span style="color:blue">vllParsers.NoSuccess</span>(msg, _) => println("Error: " + msg)
      }  
    }
}</code></pre>

<p>
Note that the API needs to load the saved grammar file from disk, so the the correct file 
path must be known (see the line with the <code>VllParsers.fromFile()</code> call). 
The API also provides other variants of this function that may be convenient in other 
situations:
</p>

<ul style="list-style-type: disc;">
  <li><code>VllParsers.fromString(java.lang.String)</code> - when the gramamar is available as a String</li>
  <li><code>VllParsers.fromXml(scala.xml.Elem)</code> - when the gramamar is available as an XML element</li>
</ul>

<p>
You can see some more examples of the use of the API in <a href="UsingTheAPI.html">Using the API</a>. 
</p>

<h2 id="BuiltinLexicalAnalyzer">Built-in Lexical Analyzer</h2>

<p>
To be defined! 
</p>

<pre><code>
</code></pre>



  </body>
</html>
