<html>
  <head>
    <title>AST Structure and Action Code</title>
  </head>

  <body>
    <h1>VisualLangLab - AST Structure and Action Code</h1>

    <p>
      The terms <i>parse-tree</i> and <i>AST</i> (short for <i>Abstract Syntax Tree</i>) 
      are used interchangably thoroughout the documentation to mean the same thing -- 
      the structure of information gathered by 
      a grammar-tree (or part of a grammar-tree) during the parsing process. 
      This is how <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Wikipedia defines AST</a>. 
    </p>

    <p>
      The discussion below explains two related issues:
      how <a href="http://vll.java.net/">VisualLangLab</a> 
      determines the structure of the AST for any grammar-tree, 
      and how the user should design and program action-code to process an AST.
    </p>

    <h2>A Smattering of Scala</h2>

    <p>
      This version of <a href="http://vll.java.net/">VisualLangLab</a> is written in 
      <a href="http://www.scala-lang.org/">Scala</a>, so the AST is expressed in terms 
      of standard Scala data-structures. While knowledge of Scala programming is not 
      needed to develop a parser, a rudimentary understanding of data-structures is 
      required for understanding the AST. 
      For a formal introduction to Scala use any of the books featured on the 
      <a href="http://www.scala-lang.org">official Scala web-site</a>.
    </p>

    <h3>Essential Data-Structures</h3>

    <p>
      The following list contains all the Scala elements used in constructing ASTs. 
      All items in the list are hyperlinked to detailed descriptions. 
    </p>

    <ul>
      <li><a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">String</a> 
          represents nodes of type <i>Literal</i> or <i>Regex</i></li>
      <li><a href="http://www.scala-lang.org/api/current/index.html#scala.Array">Array[Any]</a> 
          represents <i>Sequence</i> nodes</li>
      <li><a href="http://www.scala-lang.org/api/current/index.html#scala.Option">Option[Any]</a> 
          wraps nodes with a multiplicity of <i>?</i> (0 or 1)</li>
      <li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List">List[Any]</a> 
          wraps <i>RepSep</i> nodes, and also nodes (of any type) with a multiplicity of 
          <i>*</i> (0 or more) or <i>+</i> (1 or more)</li>
      <li><a href="http://www.scala-lang.org/api/current/scala/Predef$$Pair$.html">Pair</a> and 
          <a href="http://www.scala-lang.org/api/current/index.html#scala.Tuple2">Tuple2[Int,Any]</a> 
          represent <i>Choice</i> nodes</li>
    </ul>

    <p>
      The AST of a complete grammar-tree is built up by recursively nesting these structures 
      as required by the grammar. That is why the content-type parameter 
      is always <code>Any</code> (to permit unconstrained nesting). 
      The examples in the following discussion illustrate this concept.
    </p>

    <h3>Function Literals</h3>

    <p>
      Scala function literals are used for adding action-code to grammar-tree nodes. However, 
      this section does not provide instruction in writing Scala functions as use of 
      action-code is an option and action-code can also be written in Javascript. 
    </p>

    <h2>AST Structure</h2>

    <p>
      The structure of an AST for any particular grammar-tree is determined 
      by the arrangement, type, and multiplicity of the nodes comprising the 
      grammar-tree. Starting from the root-node, the following rules are applied recursively:
    </p>

    <ul>
      <li>The <i>Root</i> node does not influence the AST structure -- its AST is the same as 
          that of the contained tree</li>
      <li>A <i>Literal</i> token contributes a <code>String</code> (identical to the Literal itself)</li>
      <li>A <i>Regexp</i> token contributes a <code>String</code> (the <i>lexeme</i> or the matched input)</li>
      <li>A <i>Sequence</i> contributes an <code>Array[Any]</code> containing the items contributed 
          by its child nodes</li>
      <li>A <i>Choice</i> contributes a <code>Pair[Int,Any]</code> where the first member 
          is the (0-based) index of the matching alternative, and the second member 
          is the value contributed by the matched alternative</li>
      <li>A <i>RepSep</i> contributes a <code>List[Any]</code> containing all the matched items</li>
    </ul>

    <p>
      Additionally, certain annotations cause the structure defined above to be modified in
      the following ways:
    </p>

    <ul>
      <li>A node with multiplicity <i>?</i> (0 or 1) contributes an <code>Option[Any]</code>. 
          A <code>None</code> is returned if the expected item was not found in the input, 
          and a <code>Some[Any]</code> is returned if the item was present</li>
      <li>A node with a multiplicity <i>*</i> (0-or-more) or <i>+</i> (1-or-more) wraps the underlying 
          values into a <code>List[Any]</code>. A <code>Nil</code> is returned if the multiplicity 
          is <i>*</i>, and no matching elements were found in the input</li>
      <li>A node with multiplicity <i>0</i> (<i>not</i>) or <i>=</i> (<i>guard</i>) contributes 
          nothing to the AST</li>
      <li>A child node of a <i>Sequence</i> with the <i>drop</i> annotation contributes 
          nothing to the AST</li>
      <li>A <i>Sequence</i> with only one child that contributes to the AST (because all 
          other child nodes have a <i>drop</i> annotation, 
          or have multiplicities of <i>0</i> (not) or <i>=</i> (guard)) does not produce an 
          <code>Array[Any]</code>, but just passes on the AST produced by its one contributing 
          child node</li>
    </ul>

    <p>
      The examples below illustrate these principles using grammar trees from the 
      built-in parser for <i>SimpleJSON</i>. Remember that the AST shown 
      in the figures is the AST of the <i>selected</i> node. Also, remember that
      the root-node of a grammar-tree merely reflects the AST of the contained tree. 
    </p>

    <h3>Sequence Node Example</h3>

    <p>
      Figure-1 below illustrates the AST of a Sequence node. 
      It also shows the result of testing the grammar-tree with some user-provided input. 
    </p>

    <img src="images/ASTSequence.png"/><br/>
    <i>Figure-1. Sequence node AST</i>

    <p>
      The text displayed in the TextArea to the right of the grammar-tree is the structure 
      of the AST that will be used by VisualLangLab for this grammar-tree. Observe that the 
      structure is an <code>Array</code> with three elements (corresponding to the number of 
      child-nodes of the Sequence node). The format used for the array's elements is described 
      below:
    </p>

    <ul>
      <li>[stringLiteral] - this form (name of a Regex node within square brackets) represents 
          the lexeme matching the regular-expression</li>
      <li>":" - a string within double-quotes represents the string itself</li>
      <li>@Value - an <i>@</i> prefixed parser-clause (or grammar-tree) name represent the 
          AST returned by the named grammar-tree</li>
    </ul>

    <p>
      The two TextAreas at the bottom of the GUI show the result of actually testing 
      the parser. Some test input (<i>"count" : 55</i>) has been typed into the 
      <i>Parser Test Input</i> area, and the result of running the parser 
      appears under <i>Parser Log</i>. 
      The AST actually generated is on the last line of the output 
      (<i>Array("count", :, Pair(3, 55))</i>).
    </p>

    <p>
      As described in <a href="TestingParsers.html">Testing Parsers</a> the displayed 
      grammar-tree is run by choosing <i>Test -> Parse input</i> from the main menu or 
      by clicking on the corresponding toolbar button 
     (<img src="images/ToolBarButtonParseInput.gif" align="center"/>).
    </p>

    <h3>Choice Node Example</h3>

    <p>
      The grammar-tree in Figure-2 below illustrates the AST of a <i>Choice</i> node. 
    </p>

    <img src="images/ASTChoice.png"/><br/>
    <i>Figure-2. Choice node AST</i>

    <p>
      The displayed AST illustrates the format used to describe the AST of a Choice 
      node. The value actually returned by the parser is any one of the alternative 
      <code>Pair[Int,Any]</code>s shown. The first member of the <code>Pair</code> 
      is the index of the matching alternative, while the second member is the 
      value obtained by parsing the actual alternative.
    </p>

    <p>
      The text in testing area show the result of a parser run. The text <i>3.14</i> was 
      typed into the <i>Parser Test Input</i> area, and the result of the run is the 
      output <code>Pair(3, 3.14)</code> (last line under <i>Parser Log</i>). The first 
      member of the <code>Pair</code> in this example (the value <i>3</i>) is the 0-based 
      index of the matching alternative (the Regex node <i>floatingPointNumber</i>). 
    </p>

    <h3>RepSep Node Example</h3>

    <p>
      The grammar-tree in Figure-3 below illustrates the AST of a <i>RepSep</i> node. 
    </p>

    <img src="images/ASTRepSep.png"/><br/>
    <i>Figure-3. RepSep node AST</i>

    <p>
      Observe the the AST in this case is a 2-level structure -- a 
      <code>List</code> nested within an <code>Array</code>. The <code>List</code> 
      represents the <i>RepSep</i>, while the <code>Array</code> represents the 
      containing <i>Sequence</i>.
    </p>

    <p>
      The parser when tested with the following input: <i>[false, 3.14, "hello"]</i> 
      produces this AST as output: 
      <i>Array([, List(Pair(6, false), Pair(3, 3.14), Pair(2, "hello")), ])</i>.
    </p>

    <h3>Sequence Node Example with One Contributing Node</h3>

    <p>
      Our last example Figure-4 below illustrates the AST of a <i>Sequence</i> node 
      with just 1 contributing node. It also shows the effect of applying the <i>drop</i> 
      annotation to the child node of a <i>Sequence</i>.
    </p>

    <img src="images/ASTSeqWithDrop.png"/><br/>
    <i>Figure-4. Sequence node AST with 1 contributing node</i>

    <p>
      This example uses the same grammar-tree as the previous example, but applies the 
      <i>drop</i> annotation to the Literal nodes <i>LBKT</i> and <i>RBKT</i> 
      (see <a href="EditingTheGrammarTree.html">Editing the Grammar Tree</a>). The presence 
      of the attribute is clearly evident in the grammar tree from the textual annotation 
      as well as the overlay applied to the basic Literal icon.
    </p>

    <p>
      The AST changes drastically beacuse of these modifications. The two <i>drop</i>ped 
      nodes do not appear in the AST. And, since the Sequence has just one 
      child node left that contributes to the AST (the RepSep), the Sequence merely 
      passes on the AST of the RepSep. It does not need to produce an <code>Array</code>.
    </p>

    <h2>Action-Code Design</h2>

    <p>
      Within <a href="http://vll.java.net/">VisualLangLab</a> action-code is an 
      anonymous function literal in any supported programming language (see below). 
      However, there are some general principles that apply irrespective of the language.
    </p>

    <h3>General Principles</h3>
    <p>
      An action-code function literal must have one argument that can accept <i>any</i> value.
      The value returned by the function depends on the overall design of the parser.
    </p>

    <p>
      An action-code function is called twice by the parser: once before parsing of the 
      associated node begins, and again after parsing of the node has ended. 
      The first invocation allows the action-code to perform any setup actions, 
      while the second invocation is intended for AST processing. 
      The action-code function can distinguish the two invocations by testing the value 
      of its only argument. The argument has a <i>null</i> value during the first invocation, 
      but holds a reference to the AST (which is necessarily non-null) during the second 
      invocation. The action-code function must test the value of its argument and act 
      accordingly.
    </p>

    <p>
      Action-code to process a grammar-tree node's AST can be written in Scala or Javascript. 
      The following sections explain action-code design in the two supported languages.
    </p>

    <h3>Scala</h3>

    <p>
      Action-code in Scala is written as a function-literal that accepts a single 
      argument of type <code>Any</code> and returns a value of any type (depending 
      on the overall design). The code can use all of the Scala and Java APIs. 
      The following code is an example taken from the 
      <i>ArithExpr</i> parser:
    </p>

<code>
<pre>(a: Any) => a match {
    // first invocation (do nothing) ...
  case null => null
    // second invocation (process AST) ...
  case Array(f: Double, lst:List[_]) => 
    var res = f
    lst.foreach(_ match {
      case Pair(0, f2:Double) => res *= f2
      case Pair(1, f2:Double) => res /= f2
    })
    res
}</pre>
</code>

    <p>
      Scala action-code can use a predefined global object named <i>VLL</i> to store 
      collected information. It exists from start to end of the parser run. 
      This object behaves as if it has a data member called <i>value</i> 
      defined like this: <code>var value: Any = _</code>, so action-code can 
      store any value like this: <code>VLL.value = /*some value*/</code>, and 
      recover the value later by using 
      <code>VLL.value.asInstanceOf[/*some type*/]</code>. 
    </p>

    <p>
      Under the hood, any user-provided Scala code must be actually <i>compiled</i> 
      before use, so the presence of action-code in Scala does perceptibly slow 
      down the <a href="http://vll.java.net/">VisualLangLab</a> GUI at certain points. 
    </p>

    <h3>Javascript</h3>

    <p>
      Action-code in Javascript is written as an anonymous function that accepts one 
      argument and returns a value that depends on the overall design. 
      The code is interpreted by the JVM's embedded Javascript engine 
      (<a href="http://www.mozilla.org/rhino/">Rhino</a>), and can therefore 
      <a href="http://www.mozilla.org/rhino/ScriptingJava.html">use the JDK API</a>.
      The following code is an example taken from the <i>ArithExpr</i> parser:
    </p>

<code>
<pre>function (arg) {
    // first invocation (do nothing) ...
  if (!arg) {
    return;
  }
    // second invocation (process AST) ...
  switch (arg[0]) {
  case 0:
    return parseFloat(arg[1]); break;
  case 1: 
    return arg[1]; break;
  } 
}</pre>
</code>

    <p>
      Javascript action-code can use a predefined global object named <i>VLL</i> to store 
      collected information. It exists from start to end of the parser run. 
      This object has no particular data or function members, but can be modified by the 
      action-code as required.
    </p>

  </body>
</html>